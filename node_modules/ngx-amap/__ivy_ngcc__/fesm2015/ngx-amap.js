import { InjectionToken, Injectable, Inject, NgZone, EventEmitter, Component, ElementRef, Input, Output, ɵɵdefineInjectable, ɵɵinject, QueryList, Directive, ContentChildren, NgModule } from '@angular/core';
import { ReplaySubject, Observable, of, EMPTY, zip, combineLatest } from 'rxjs';
import { map, switchMap, switchMapTo } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: shared/ngx-amap-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
function NgxAmapConfig() { }
if (false) {
    /** @type {?|undefined} */
    NgxAmapConfig.prototype.apiKey;
    /** @type {?|undefined} */
    NgxAmapConfig.prototype.apiVersion;
    /** @type {?|undefined} */
    NgxAmapConfig.prototype.uiVersion;
    /** @type {?|undefined} */
    NgxAmapConfig.prototype.protocol;
    /** @type {?|undefined} */
    NgxAmapConfig.prototype.debug;
    /** @type {?|undefined} */
    NgxAmapConfig.prototype.debugTags;
}
/** @type {?} */
const NGX_AMAP_CONFIG = new InjectionToken('NGX_AMAP_CONFIG');

/**
 * @fileoverview added by tsickle
 * Generated from: shared/logger/logger.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoggerService {
    constructor() { }
    /**
     * @param {...?} args
     * @return {?}
     */
    i(...args) {
        console.log(...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    e(...args) {
        console.error(...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    w(...args) {
        console.warn(...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    d(...args) {
        // only stub;
    }
}
LoggerService.ɵfac = function LoggerService_Factory(t) { return new (t || LoggerService)(); };
LoggerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LoggerService, factory: LoggerService.ɵfac });
/** @nocollapse */
LoggerService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoggerService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: shared/logger/debug-logger.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DebugLoggerService {
    /**
     * @param {?=} config
     */
    constructor(config = {}) {
        this.config = config;
        this.debugTags = [];
        this.debugAll = true;
        if (config.debugTags) {
            if (config.debugTags === '*') {
                this.debugAll = true;
            }
            else {
                this.debugAll = false;
                this.debugTags = config.debugTags.split(',');
            }
        }
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    i(...args) {
        console.log(...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    e(...args) {
        console.error(...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    w(...args) {
        console.warn(...args);
    }
    /**
     * @param {?} tag
     * @param {...?} args
     * @return {?}
     */
    d(tag, ...args) {
        if (this.debugAll || this.debugTags.includes(tag)) {
            console.log(`[${tag}]`, ...args);
        }
    }
}
DebugLoggerService.ɵfac = function DebugLoggerService_Factory(t) { return new (t || DebugLoggerService)(ɵngcc0.ɵɵinject(NGX_AMAP_CONFIG)); };
DebugLoggerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DebugLoggerService, factory: DebugLoggerService.ɵfac });
/** @nocollapse */
DebugLoggerService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGX_AMAP_CONFIG,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DebugLoggerService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NGX_AMAP_CONFIG]
            }] }]; }, null); })();
if (false) {
    /** @type {?} */
    DebugLoggerService.prototype.debugTags;
    /** @type {?} */
    DebugLoggerService.prototype.debugAll;
    /**
     * @type {?}
     * @private
     */
    DebugLoggerService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/amap-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG = 'AMapLoader';
class AMapLoaderService {
    /**
     * @param {?=} config
     * @param {?=} logger
     */
    constructor(config = {}, logger) {
        this.config = config;
        this.logger = logger;
        this.defaultProtocol = 'https';
        this.defaultVersion = '1.4.15';
        this.defaultUIVersion = '1.0.11';
        this.config = config || {};
    }
    /**
     * @return {?}
     */
    load() {
        if (this.loading$) {
            return this.loading$.asObservable();
        }
        this.logger.d(TAG, 'loading AMap API ...');
        this.loading$ = new ReplaySubject();
        /** @type {?} */
        const callbackName = '_NgxAmapAPILoader';
        /** @type {?} */
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.src = this.getSrcFromConfig(callbackName);
        script.onerror = (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.logger.e('failed to load AMap API.');
            this.loading$.error(err);
        });
        window[callbackName] = (/**
         * @return {?}
         */
        () => {
            this.logger.d(TAG, 'loading AMap API COMPLETE');
            this.loading$.next();
            this.loading$.complete();
        });
        document.body.appendChild(script);
        return this.loading$.asObservable();
    }
    /**
     * @return {?}
     */
    loadUI() {
        if (this.uiLoading$) {
            return this.uiLoading$.asObservable();
        }
        this.logger.d(TAG, 'loading AMap UI ...');
        this.uiLoading$ = new ReplaySubject();
        /** @type {?} */
        const uiScript = document.createElement('script');
        uiScript.type = 'text/javascript';
        uiScript.async = true;
        uiScript.defer = true;
        uiScript.src = this.getUISrcFromConfig();
        uiScript.onerror = (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.logger.e('failed to load AMap API.');
        });
        uiScript.onload = (/**
         * @return {?}
         */
        () => {
            // tslint:disable-next-line: no-string-literal
            window['initAMapUI']();
            this.logger.d(TAG, 'loading AMap UI COMPLETE');
            this.uiLoading$.next();
            this.uiLoading$.complete();
        });
        document.body.appendChild(uiScript);
        return this.uiLoading$.asObservable();
    }
    /**
     * @private
     * @param {?} callbackName
     * @return {?}
     */
    getSrcFromConfig(callbackName) {
        /** @type {?} */
        const urlBase = `${this.config.protocol || this.defaultProtocol}://webapi.amap.com/maps`;
        /** @type {?} */
        const queryParams = {
            v: this.config.apiVersion || this.defaultVersion,
            callback: callbackName,
            key: this.config.apiKey,
        };
        /** @type {?} */
        const params = Object.keys(queryParams)
            .filter((/**
         * @param {?} k
         * @return {?}
         */
        (k) => queryParams[k] != null))
            .filter((/**
         * @param {?} k
         * @return {?}
         */
        (k) => {
            // remove empty arrays
            return (!Array.isArray(queryParams[k]) ||
                (Array.isArray(queryParams[k]) && queryParams[k].length > 0));
        }))
            .map((/**
         * @param {?} k
         * @return {?}
         */
        (k) => {
            // join arrays as comma seperated strings
            /** @type {?} */
            const i = queryParams[k];
            if (Array.isArray(i)) {
                return { key: k, value: i.join(',') };
            }
            return { key: k, value: queryParams[k] };
        }))
            .map((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => `${entry.key}=${entry.value}`))
            .join('&');
        return `${urlBase}?${params}`;
    }
    /**
     * @private
     * @return {?}
     */
    getUISrcFromConfig() {
        // tslint:disable-next-line: max-line-length
        /** @type {?} */
        const urlBase = `${this.config.protocol ||
            this.defaultProtocol}://webapi.amap.com/ui/1.0/main-async.js?v=${this.config.uiVersion ||
            this.defaultUIVersion}`;
        return urlBase;
    }
}
AMapLoaderService.ɵfac = function AMapLoaderService_Factory(t) { return new (t || AMapLoaderService)(ɵngcc0.ɵɵinject(NGX_AMAP_CONFIG), ɵngcc0.ɵɵinject(LoggerService)); };
AMapLoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AMapLoaderService, factory: AMapLoaderService.ɵfac });
/** @nocollapse */
AMapLoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGX_AMAP_CONFIG,] }] },
    { type: LoggerService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AMapLoaderService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NGX_AMAP_CONFIG]
            }] }, { type: LoggerService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.defaultProtocol;
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.defaultVersion;
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.defaultUIVersion;
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.loading$;
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.uiLoading$;
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    AMapLoaderService.prototype.logger;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/amap.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$1 = 'AMap';
class AMapService {
    /**
     * @param {?} loader
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(loader, logger, ngZone) {
        this.loader = loader;
        this.logger = logger;
        this.ngZone = ngZone;
        this.map$ = new ReplaySubject();
    }
    /**
     * 获取地图对象 AMap.Map
     * @return {?}
     */
    get() {
        return this.map$.asObservable();
    }
    /**
     * 创建地图对象 AMap.Map
     * @param {?} container 地图容器的DOM元素
     * @param {?} options 选项
     * @return {?}
     */
    create(container, options) {
        return this.loader.load().pipe(map((/**
         * @return {?}
         */
        () => {
            this.map = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Map(container, options)));
            this.logger.d(TAG$1, 'new map created.');
            this.map$.next(this.map);
            this.map$.complete();
            return this.map;
        })));
    }
    /**
     * 销毁地图对象
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.destroy();
            this.logger.d(TAG$1, 'map destroyed.');
            this.map = null;
        }));
    }
}
AMapService.ɵfac = function AMapService_Factory(t) { return new (t || AMapService)(ɵngcc0.ɵɵinject(AMapLoaderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AMapService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AMapService, factory: AMapService.ɵfac });
/** @nocollapse */
AMapService.ctorParameters = () => [
    { type: AMapLoaderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AMapService, [{
        type: Injectable
    }], function () { return [{ type: AMapLoaderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AMapService.prototype.map;
    /**
     * @type {?}
     * @private
     */
    AMapService.prototype.map$;
    /**
     * @type {?}
     * @private
     */
    AMapService.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    AMapService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AMapService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/event-binder.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$2 = 'EventBinder';
class EventBinderService {
    /**
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(logger, ngZone) {
        this.logger = logger;
        this.ngZone = ngZone;
    }
    /**
     * 注册事件
     * @template T
     * @param {?} target
     * @param {?} eventName 事件名
     * @return {?}
     */
    bindEvent(target, eventName) {
        return (/** @type {?} */ (target.pipe(switchMap((/**
         * @param {?} t
         * @return {?}
         */
        (t) => new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            /** @type {?} */
            let handler = AMap.event.addListener(t, eventName, (/**
             * @param {?} e
             * @return {?}
             */
            e => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => observer.next(e)));
            }), this);
            this.logger.d(TAG$2, `subscribed event: ${eventName}`);
            return (/**
             * @return {?}
             */
            () => {
                AMap.event.removeListener(handler);
                this.logger.d(TAG$2, `unsubscribed event: ${eventName}`);
                eventName = null;
                handler = null;
            });
        })))))));
    }
}
EventBinderService.ɵfac = function EventBinderService_Factory(t) { return new (t || EventBinderService)(ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
EventBinderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: EventBinderService, factory: EventBinderService.ɵfac });
/** @nocollapse */
EventBinderService.ctorParameters = () => [
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventBinderService, [{
        type: Injectable
    }], function () { return [{ type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    EventBinderService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    EventBinderService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/plugin-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$3 = 'PluginLoader';
class PluginLoaderService {
    /**
     * @param {?} amap
     * @param {?} logger
     */
    constructor(amap, logger) {
        this.amap = amap;
        this.logger = logger;
        this.state = new Map();
    }
    /**
     * @param {?} name
     * @return {?}
     */
    load(name) {
        /** @type {?} */
        let pKey = '';
        if (Array.isArray(name)) {
            pKey = name.join(',');
        }
        else {
            pKey = name;
        }
        if (this.state.has(pKey)) {
            return this.state.get(pKey).asObservable();
        }
        this.logger.d(TAG$3, 'loading plugin:', pKey, '...');
        return this.amap.get().pipe(switchMap((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            /** @type {?} */
            const loading$ = new ReplaySubject(1);
            m.plugin(name, (/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$3, 'loading plugin:', pKey, 'COMPLETE');
                loading$.next();
                loading$.complete();
            }));
            this.state.set(pKey, loading$);
            return loading$.asObservable();
        })));
    }
}
PluginLoaderService.ɵfac = function PluginLoaderService_Factory(t) { return new (t || PluginLoaderService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService)); };
PluginLoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PluginLoaderService, factory: PluginLoaderService.ɵfac });
/** @nocollapse */
PluginLoaderService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PluginLoaderService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    PluginLoaderService.prototype.state;
    /**
     * @type {?}
     * @private
     */
    PluginLoaderService.prototype.amap;
    /**
     * @type {?}
     * @private
     */
    PluginLoaderService.prototype.logger;
}

/**
 * @fileoverview added by tsickle
 * Generated from: utils/change-filter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChangeFilter {
    /**
     * @param {?} changes
     */
    constructor(changes) {
        this.changes = changes;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    static of(changes) {
        return new ChangeFilter(changes);
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    notEmpty(key) {
        if (this.changes[key]) {
            /** @type {?} */
            const value = this.changes[key].currentValue;
            if (value !== undefined && value !== null) {
                return of(value);
            }
        }
        return EMPTY;
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    has(key) {
        if (this.changes[key]) {
            /** @type {?} */
            const value = this.changes[key].currentValue;
            return of(value);
        }
        return EMPTY;
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ChangeFilter.prototype.changes;
}

/**
 * @fileoverview added by tsickle
 * Generated from: utils/get-options.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} component
 * @param {?} keys
 * @return {?}
 */
function getOptions(component, keys) {
    /** @type {?} */
    const options = {};
    keys.forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        if (component[key] !== undefined && component[key] !== null) {
            options[key] = component[key];
        }
    }));
    return options;
}

/**
 * @fileoverview added by tsickle
 * Generated from: utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: components/ngx-amap/ngx-amap.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$4 = 'ngx-amap';
/** @type {?} */
const ALL_OPTIONS = [
    'view',
    'layers',
    'zoom',
    'center',
    'labelzIndex',
    'zooms',
    'lang',
    'defaultCursor',
    'crs',
    'animateEnable',
    'isHotspot',
    'defaultLayer',
    'rotateEnable',
    'resizeEnable',
    'showIndoorMap',
    'indoorMap',
    'expandZoomRange',
    'dragEnable',
    'zoomEnable',
    'doubleClickZoom',
    'keyboardEnable',
    'jogEnable',
    'scrollWheel',
    'touchZoom',
    'touchZoomCenter',
    'mapStyle',
    'features',
    'showBuildingBlock',
    'viewMode',
    'pitch',
    'pitchEnable',
    'buildingAnimation',
    'skyColor',
    'preloadMode',
    'mask',
    'maxPitch',
    'rotation',
    'forceVector',
    'gridMapForeign',
    'vectorMapForeign',
];
class NgxAmapComponent {
    /**
     * @param {?} el
     * @param {?} amap
     * @param {?} pluginLoader
     * @param {?} logger
     * @param {?} binder
     * @param {?} ngZone
     */
    constructor(el, amap, pluginLoader, logger, binder, ngZone) {
        this.el = el;
        this.amap = amap;
        this.pluginLoader = pluginLoader;
        this.logger = logger;
        this.binder = binder;
        this.ngZone = ngZone;
        // ---- Map Events ----
        this.naReady = new EventEmitter();
        this.naPluginsLoaded = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        const m = this.amap.get();
        this.naComplete = this.binder.bindEvent(m, 'complete');
        this.naClick = this.binder.bindEvent(m, 'click');
        this.naDblClick = this.binder.bindEvent(m, 'dblclick');
        this.naRightClick = this.binder.bindEvent(m, 'rightclick');
        this.naMouseMove = this.binder.bindEvent(m, 'mousemove');
        this.naMouseOver = this.binder.bindEvent(m, 'mouseover');
        this.naMouseWheel = this.binder.bindEvent(m, 'mousewheel');
        this.naMouseUp = this.binder.bindEvent(m, 'mouseup');
        this.naMouseOut = this.binder.bindEvent(m, 'mouseout');
        this.naMouseDown = this.binder.bindEvent(m, 'mousedown');
        this.naTouchStart = this.binder.bindEvent(m, 'touchstart');
        this.naTouchMove = this.binder.bindEvent(m, 'touchmove');
        this.naTouchEnd = this.binder.bindEvent(m, 'touchend');
        this.naHotspotClick = this.binder.bindEvent(m, 'hotspotclick');
        this.naHotspotOver = this.binder.bindEvent(m, 'hotspotover');
        this.naHotspotOut = this.binder.bindEvent(m, 'hotspotout');
        this.naDragStart = this.binder.bindEvent(m, 'dragstart');
        this.naDragging = this.binder.bindEvent(m, 'dragging');
        this.naDragEnd = this.binder.bindEvent(m, 'dragend');
        this.naResize = this.binder.bindEvent(m, 'resize');
        this.naZoomStart = this.binder.bindEvent(m, 'zoomstart');
        this.naZoomEnd = this.binder.bindEvent(m, 'zoomend');
        this.naZoomChange = this.binder.bindEvent(m, 'zoomchange');
        this.naMoveStart = this.binder.bindEvent(m, 'movestart');
        this.naMoveEnd = this.binder.bindEvent(m, 'moveend');
        this.naMove = this.binder.bindEvent(m, 'mapmove');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.logger.d(TAG$4, 'initializing ...');
        /** @type {?} */
        const container = this.el.nativeElement.querySelector('div.ngx-amap-container-inner');
        /** @type {?} */
        const options = getOptions(this, ALL_OPTIONS);
        this.logger.d(TAG$4, 'options:', options);
        this.amap.create(container, options).subscribe((/**
         * @param {?} amap
         * @return {?}
         */
        amap => {
            this.logger.d(TAG$4, 'map is ready.');
            this.ngZone.run((/**
             * @return {?}
             */
            () => this.naReady.emit(amap)));
        }));
        this.inited = true;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.amap.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const amap = this.get();
        if (this.inited) {
            zip(filter.has('zoom'), amap).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => {
                this.logger.d(TAG$4, 'setZoom:', v);
                m.setZoom(v);
            }));
            zip(filter.has('center'), amap).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => {
                this.logger.d(TAG$4, 'setCenter:', v);
                m.setCenter(v);
            }));
        }
        // Not included in OPTIONS
        zip(filter.has('city'), amap).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => {
            m.setCity(v, (/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$4, 'setCity:', v);
            }));
        }));
        zip(filter.notEmpty('plugins'), amap).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => {
            this.pluginLoader.load(v).subscribe((/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$4, 'plugins loaded.');
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naPluginsLoaded.emit(m)));
            }));
        }));
    }
    /**
     * 获取已创建的 AMap.Map 对象
     * @return {?}
     */
    get() {
        return this.amap.get();
    }
}
NgxAmapComponent.ɵfac = function NgxAmapComponent_Factory(t) { return new (t || NgxAmapComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(PluginLoaderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NgxAmapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxAmapComponent, selectors: [["ngx-amap"]], inputs: { view: "view", layers: "layers", zoom: "zoom", center: "center", labelzIndex: "labelzIndex", zooms: "zooms", lang: "lang", defaultCursor: "defaultCursor", crs: "crs", animateEnable: "animateEnable", isHotspot: "isHotspot", defaultLayer: "defaultLayer", rotateEnable: "rotateEnable", resizeEnable: "resizeEnable", showIndoorMap: "showIndoorMap", indoorMap: "indoorMap", expandZoomRange: "expandZoomRange", dragEnable: "dragEnable", zoomEnable: "zoomEnable", doubleClickZoom: "doubleClickZoom", keyboardEnable: "keyboardEnable", jogEnable: "jogEnable", scrollWheel: "scrollWheel", touchZoom: "touchZoom", touchZoomCenter: "touchZoomCenter", mapStyle: "mapStyle", features: "features", showBuildingBlock: "showBuildingBlock", viewMode: "viewMode", pitch: "pitch", pitchEnable: "pitchEnable", buildingAnimation: "buildingAnimation", skyColor: "skyColor", preloadMode: "preloadMode", mask: "mask", maxPitch: "maxPitch", rotation: "rotation", forceVector: "forceVector", gridMapForeign: "gridMapForeign", vectorMapForeign: "vectorMapForeign", city: "city", name: "name", plugins: "plugins" }, outputs: { naReady: "naReady", naPluginsLoaded: "naPluginsLoaded", naComplete: "naComplete", naClick: "naClick", naDblClick: "naDblClick", naRightClick: "naRightClick", naMouseMove: "naMouseMove", naMouseOver: "naMouseOver", naMouseWheel: "naMouseWheel", naMouseUp: "naMouseUp", naMouseOut: "naMouseOut", naMouseDown: "naMouseDown", naTouchStart: "naTouchStart", naTouchMove: "naTouchMove", naTouchEnd: "naTouchEnd", naHotspotClick: "naHotspotClick", naHotspotOver: "naHotspotOver", naHotspotOut: "naHotspotOut", naDragStart: "naDragStart", naDragging: "naDragging", naDragEnd: "naDragEnd", naResize: "naResize", naZoomStart: "naZoomStart", naZoomEnd: "naZoomEnd", naZoomChange: "naZoomChange", naMoveStart: "naMoveStart", naMoveEnd: "naMoveEnd", naMove: "naMove" }, exportAs: ["amap"], features: [ɵngcc0.ɵɵProvidersFeature([AMapService, PluginLoaderService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 0, consts: [[1, "ngx-amap-container-inner"], [1, "ngx-amap-content"]], template: function NgxAmapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [".ngx-amap-container-inner[_ngcontent-%COMP%]{width:inherit;height:inherit}.ngx-amap-content[_ngcontent-%COMP%]{display:none}"] });
/** @nocollapse */
NgxAmapComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AMapService },
    { type: PluginLoaderService },
    { type: LoggerService },
    { type: EventBinderService },
    { type: NgZone }
];
NgxAmapComponent.propDecorators = {
    view: [{ type: Input }],
    layers: [{ type: Input }],
    zoom: [{ type: Input }],
    center: [{ type: Input }],
    labelzIndex: [{ type: Input }],
    zooms: [{ type: Input }],
    lang: [{ type: Input }],
    defaultCursor: [{ type: Input }],
    crs: [{ type: Input }],
    animateEnable: [{ type: Input }],
    isHotspot: [{ type: Input }],
    defaultLayer: [{ type: Input }],
    rotateEnable: [{ type: Input }],
    resizeEnable: [{ type: Input }],
    showIndoorMap: [{ type: Input }],
    indoorMap: [{ type: Input }],
    expandZoomRange: [{ type: Input }],
    dragEnable: [{ type: Input }],
    zoomEnable: [{ type: Input }],
    doubleClickZoom: [{ type: Input }],
    keyboardEnable: [{ type: Input }],
    jogEnable: [{ type: Input }],
    scrollWheel: [{ type: Input }],
    touchZoom: [{ type: Input }],
    touchZoomCenter: [{ type: Input }],
    mapStyle: [{ type: Input }],
    features: [{ type: Input }],
    showBuildingBlock: [{ type: Input }],
    viewMode: [{ type: Input }],
    pitch: [{ type: Input }],
    pitchEnable: [{ type: Input }],
    buildingAnimation: [{ type: Input }],
    skyColor: [{ type: Input }],
    preloadMode: [{ type: Input }],
    mask: [{ type: Input }],
    maxPitch: [{ type: Input }],
    rotation: [{ type: Input }],
    forceVector: [{ type: Input }],
    gridMapForeign: [{ type: Input }],
    vectorMapForeign: [{ type: Input }],
    city: [{ type: Input }],
    name: [{ type: Input }],
    plugins: [{ type: Input }],
    naReady: [{ type: Output }],
    naComplete: [{ type: Output }],
    naClick: [{ type: Output }],
    naDblClick: [{ type: Output }],
    naRightClick: [{ type: Output }],
    naMouseMove: [{ type: Output }],
    naMouseOver: [{ type: Output }],
    naMouseWheel: [{ type: Output }],
    naMouseUp: [{ type: Output }],
    naMouseOut: [{ type: Output }],
    naMouseDown: [{ type: Output }],
    naTouchStart: [{ type: Output }],
    naTouchMove: [{ type: Output }],
    naTouchEnd: [{ type: Output }],
    naHotspotClick: [{ type: Output }],
    naHotspotOver: [{ type: Output }],
    naHotspotOut: [{ type: Output }],
    naDragStart: [{ type: Output }],
    naDragging: [{ type: Output }],
    naDragEnd: [{ type: Output }],
    naResize: [{ type: Output }],
    naZoomStart: [{ type: Output }],
    naZoomEnd: [{ type: Output }],
    naZoomChange: [{ type: Output }],
    naMoveStart: [{ type: Output }],
    naMoveEnd: [{ type: Output }],
    naMove: [{ type: Output }],
    naPluginsLoaded: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxAmapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-amap',
                exportAs: 'amap',
                template: "<div class='ngx-amap-container-inner'></div>\n<div class='ngx-amap-content'>\n  <ng-content></ng-content>\n</div>",
                providers: [AMapService, PluginLoaderService],
                styles: [".ngx-amap-container-inner{width:inherit;height:inherit}.ngx-amap-content{display:none}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: AMapService }, { type: PluginLoaderService }, { type: LoggerService }, { type: EventBinderService }, { type: ɵngcc0.NgZone }]; }, { naReady: [{
            type: Output
        }], naPluginsLoaded: [{
            type: Output
        }], naComplete: [{
            type: Output
        }], naClick: [{
            type: Output
        }], naDblClick: [{
            type: Output
        }], naRightClick: [{
            type: Output
        }], naMouseMove: [{
            type: Output
        }], naMouseOver: [{
            type: Output
        }], naMouseWheel: [{
            type: Output
        }], naMouseUp: [{
            type: Output
        }], naMouseOut: [{
            type: Output
        }], naMouseDown: [{
            type: Output
        }], naTouchStart: [{
            type: Output
        }], naTouchMove: [{
            type: Output
        }], naTouchEnd: [{
            type: Output
        }], naHotspotClick: [{
            type: Output
        }], naHotspotOver: [{
            type: Output
        }], naHotspotOut: [{
            type: Output
        }], naDragStart: [{
            type: Output
        }], naDragging: [{
            type: Output
        }], naDragEnd: [{
            type: Output
        }], naResize: [{
            type: Output
        }], naZoomStart: [{
            type: Output
        }], naZoomEnd: [{
            type: Output
        }], naZoomChange: [{
            type: Output
        }], naMoveStart: [{
            type: Output
        }], naMoveEnd: [{
            type: Output
        }], naMove: [{
            type: Output
        }], view: [{
            type: Input
        }], layers: [{
            type: Input
        }], zoom: [{
            type: Input
        }], center: [{
            type: Input
        }], labelzIndex: [{
            type: Input
        }], zooms: [{
            type: Input
        }], lang: [{
            type: Input
        }], defaultCursor: [{
            type: Input
        }], crs: [{
            type: Input
        }], animateEnable: [{
            type: Input
        }], isHotspot: [{
            type: Input
        }], defaultLayer: [{
            type: Input
        }], rotateEnable: [{
            type: Input
        }], resizeEnable: [{
            type: Input
        }], showIndoorMap: [{
            type: Input
        }], indoorMap: [{
            type: Input
        }], expandZoomRange: [{
            type: Input
        }], dragEnable: [{
            type: Input
        }], zoomEnable: [{
            type: Input
        }], doubleClickZoom: [{
            type: Input
        }], keyboardEnable: [{
            type: Input
        }], jogEnable: [{
            type: Input
        }], scrollWheel: [{
            type: Input
        }], touchZoom: [{
            type: Input
        }], touchZoomCenter: [{
            type: Input
        }], mapStyle: [{
            type: Input
        }], features: [{
            type: Input
        }], showBuildingBlock: [{
            type: Input
        }], viewMode: [{
            type: Input
        }], pitch: [{
            type: Input
        }], pitchEnable: [{
            type: Input
        }], buildingAnimation: [{
            type: Input
        }], skyColor: [{
            type: Input
        }], preloadMode: [{
            type: Input
        }], mask: [{
            type: Input
        }], maxPitch: [{
            type: Input
        }], rotation: [{
            type: Input
        }], forceVector: [{
            type: Input
        }], gridMapForeign: [{
            type: Input
        }], vectorMapForeign: [{
            type: Input
        }], city: [{
            type: Input
        }], name: [{
            type: Input
        }], plugins: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 地图视口，用于控制影响地图静态显示的属性
     * @type {?}
     */
    NgxAmapComponent.prototype.view;
    /**
     * 地图图层数组，数组可以是图层 中的一个或多个，默认为普通二维地图
     * @type {?}
     */
    NgxAmapComponent.prototype.layers;
    /**
     * 地图显示的缩放级别
     * @type {?}
     */
    NgxAmapComponent.prototype.zoom;
    /**
     * 地图中心点坐标值
     * @type {?}
     */
    NgxAmapComponent.prototype.center;
    /**
     * 地图标注显示顺序
     * @type {?}
     */
    NgxAmapComponent.prototype.labelzIndex;
    /**
     * 地图显示的缩放级别范围
     * @type {?}
     */
    NgxAmapComponent.prototype.zooms;
    /**
     * 地图语言类型
     * @type {?}
     */
    NgxAmapComponent.prototype.lang;
    /**
     * 地图默认鼠标样式
     * @type {?}
     */
    NgxAmapComponent.prototype.defaultCursor;
    /**
     * 地图显示的参考坐标系
     * @type {?}
     */
    NgxAmapComponent.prototype.crs;
    /**
     * 地图平移过程中是否使用动画
     * @type {?}
     */
    NgxAmapComponent.prototype.animateEnable;
    /**
     * 是否开启地图热点和标注的hover效果
     * @type {?}
     */
    NgxAmapComponent.prototype.isHotspot;
    /**
     * 当前地图中默认显示的图层
     * @type {?}
     */
    NgxAmapComponent.prototype.defaultLayer;
    /**
     * 地图是否可旋转
     * @type {?}
     */
    NgxAmapComponent.prototype.rotateEnable;
    /**
     * 是否监控地图容器尺寸变化
     * @type {?}
     */
    NgxAmapComponent.prototype.resizeEnable;
    /**
     * 是否在有矢量底图的时候自动展示室内地图
     * @type {?}
     */
    NgxAmapComponent.prototype.showIndoorMap;
    /**
     * 在展示矢量图的时候自动展示室内地图图层
     * @type {?}
     */
    NgxAmapComponent.prototype.indoorMap;
    /**
     * 是否支持可以扩展最大缩放级别
     * @type {?}
     */
    NgxAmapComponent.prototype.expandZoomRange;
    /**
     * 地图是否可通过鼠标拖拽平移
     * @type {?}
     */
    NgxAmapComponent.prototype.dragEnable;
    /**
     * 地图是否可缩放
     * @type {?}
     */
    NgxAmapComponent.prototype.zoomEnable;
    /**
     * 地图是否可通过双击鼠标放大地图
     * @type {?}
     */
    NgxAmapComponent.prototype.doubleClickZoom;
    /**
     * 地图是否可通过键盘控制
     * @type {?}
     */
    NgxAmapComponent.prototype.keyboardEnable;
    /**
     * 地图是否使用缓动效果
     * @type {?}
     */
    NgxAmapComponent.prototype.jogEnable;
    /**
     * 地图是否可通过鼠标滚轮缩放浏览
     * @type {?}
     */
    NgxAmapComponent.prototype.scrollWheel;
    /**
     * 地图在移动终端上是否可通过多点触控缩放浏览地图
     * @type {?}
     */
    NgxAmapComponent.prototype.touchZoom;
    /**
     * 当touchZoomCenter=1的时候，手机端双指缩放的以地图中心为中心，否则默认以双指中间点为中心
     * @type {?}
     */
    NgxAmapComponent.prototype.touchZoomCenter;
    /**
     * 设置地图的显示样式
     * @type {?}
     */
    NgxAmapComponent.prototype.mapStyle;
    /**
     * 设置地图上显示的元素种类
     * @type {?}
     */
    NgxAmapComponent.prototype.features;
    /**
     * 设置地图显示3D楼块效果
     * @type {?}
     */
    NgxAmapComponent.prototype.showBuildingBlock;
    /**
     * 视图模式
     * @type {?}
     */
    NgxAmapComponent.prototype.viewMode;
    /**
     * 俯仰角度
     * @type {?}
     */
    NgxAmapComponent.prototype.pitch;
    /**
     * 是否允许设置俯仰角度
     * @type {?}
     */
    NgxAmapComponent.prototype.pitchEnable;
    /**
     * 楼块出现和消失的时候是否显示动画过程
     * @type {?}
     */
    NgxAmapComponent.prototype.buildingAnimation;
    /**
     * 调整天空颜色
     * @type {?}
     */
    NgxAmapComponent.prototype.skyColor;
    /**
     * 设置地图的预加载模式
     * @type {?}
     */
    NgxAmapComponent.prototype.preloadMode;
    /**
     * 为 Map 实例指定掩模的路径，各图层将只显示路径范围内图像
     * @type {?}
     */
    NgxAmapComponent.prototype.mask;
    /** @type {?} */
    NgxAmapComponent.prototype.maxPitch;
    /** @type {?} */
    NgxAmapComponent.prototype.rotation;
    /** @type {?} */
    NgxAmapComponent.prototype.forceVector;
    /** @type {?} */
    NgxAmapComponent.prototype.gridMapForeign;
    /**
     * 额外: 海外⽮量地图样式
     * @type {?}
     */
    NgxAmapComponent.prototype.vectorMapForeign;
    /**
     * 额外: 设置城市
     * @type {?}
     */
    NgxAmapComponent.prototype.city;
    /**
     * 额外: 设置地图名
     * @type {?}
     */
    NgxAmapComponent.prototype.name;
    /**
     * 额外：加载插件
     * @type {?}
     */
    NgxAmapComponent.prototype.plugins;
    /** @type {?} */
    NgxAmapComponent.prototype.naReady;
    /** @type {?} */
    NgxAmapComponent.prototype.naComplete;
    /** @type {?} */
    NgxAmapComponent.prototype.naClick;
    /** @type {?} */
    NgxAmapComponent.prototype.naDblClick;
    /** @type {?} */
    NgxAmapComponent.prototype.naRightClick;
    /** @type {?} */
    NgxAmapComponent.prototype.naMouseMove;
    /** @type {?} */
    NgxAmapComponent.prototype.naMouseOver;
    /** @type {?} */
    NgxAmapComponent.prototype.naMouseWheel;
    /** @type {?} */
    NgxAmapComponent.prototype.naMouseUp;
    /** @type {?} */
    NgxAmapComponent.prototype.naMouseOut;
    /** @type {?} */
    NgxAmapComponent.prototype.naMouseDown;
    /** @type {?} */
    NgxAmapComponent.prototype.naTouchStart;
    /** @type {?} */
    NgxAmapComponent.prototype.naTouchMove;
    /** @type {?} */
    NgxAmapComponent.prototype.naTouchEnd;
    /** @type {?} */
    NgxAmapComponent.prototype.naHotspotClick;
    /** @type {?} */
    NgxAmapComponent.prototype.naHotspotOver;
    /** @type {?} */
    NgxAmapComponent.prototype.naHotspotOut;
    /** @type {?} */
    NgxAmapComponent.prototype.naDragStart;
    /** @type {?} */
    NgxAmapComponent.prototype.naDragging;
    /** @type {?} */
    NgxAmapComponent.prototype.naDragEnd;
    /** @type {?} */
    NgxAmapComponent.prototype.naResize;
    /** @type {?} */
    NgxAmapComponent.prototype.naZoomStart;
    /** @type {?} */
    NgxAmapComponent.prototype.naZoomEnd;
    /** @type {?} */
    NgxAmapComponent.prototype.naZoomChange;
    /** @type {?} */
    NgxAmapComponent.prototype.naMoveStart;
    /** @type {?} */
    NgxAmapComponent.prototype.naMoveEnd;
    /** @type {?} */
    NgxAmapComponent.prototype.naMove;
    /** @type {?} */
    NgxAmapComponent.prototype.naPluginsLoaded;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.inited;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.amap;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.pluginLoader;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    NgxAmapComponent.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-marker/amap-marker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$5 = 'AmapMarker';
class AmapMarkerService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, logger, ngZone) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.marker$ = new ReplaySubject(1);
    }
    /**
     * 获取点标记
     * @return {?}
     */
    get() {
        return this.marker$.asObservable();
    }
    /**
     * 创建点标记 AMap.Marker
     * @param {?} options 选项
     * @param {?=} addToMap 是否直接加进地图
     * @return {?}
     */
    create(options, addToMap = true) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            if (addToMap) {
                options.map = m;
            }
            this.marker = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Marker(options)));
            this.logger.d(TAG$5, 'new marker created.');
            this.marker$.next(this.marker);
            this.marker$.complete();
            return this.marker;
        })));
    }
    /**
     * 销毁点标记
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$5, 'marker destroyed.');
            this.marker = null;
        }));
    }
}
AmapMarkerService.ɵfac = function AmapMarkerService_Factory(t) { return new (t || AmapMarkerService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapMarkerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapMarkerService, factory: AmapMarkerService.ɵfac });
/** @nocollapse */
AmapMarkerService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapMarkerService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapMarkerService.prototype.marker;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerService.prototype.marker$;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: base/amap-overlay.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OverlayOptions = ['cursor', 'extData', 'bubble', 'clickable', 'draggable'];
/**
 * @template T
 */
class AMapOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     */
    constructor(os, binder) {
        this.os = os;
        this.binder = binder;
        /** @type {?} */
        const target = os.get();
        this.naTouchStart = this.binder.bindEvent(target, 'touchstart');
        this.naTouchMove = this.binder.bindEvent(target, 'touchmove');
        this.naTouchEnd = this.binder.bindEvent(target, 'touchend');
        this.naClick = this.binder.bindEvent(target, 'click');
        this.naDblClick = this.binder.bindEvent(target, 'dblclick');
        this.naRightClick = this.binder.bindEvent(target, 'rightclick');
        this.naMouseOver = this.binder.bindEvent(target, 'mouseover');
        this.naMouseUp = this.binder.bindEvent(target, 'mouseup');
        this.naMouseOut = this.binder.bindEvent(target, 'mouseout');
        this.naMouseDown = this.binder.bindEvent(target, 'mousedown');
    }
}
AMapOverlay.ɵfac = function AMapOverlay_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AMapOverlay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AMapOverlay, inputs: { cursor: "cursor", extData: "extData", bubble: "bubble", clickable: "clickable", draggable: "draggable" }, outputs: { naTouchStart: "naTouchStart", naTouchMove: "naTouchMove", naTouchEnd: "naTouchEnd", naClick: "naClick", naDblClick: "naDblClick", naRightClick: "naRightClick", naMouseOver: "naMouseOver", naMouseUp: "naMouseUp", naMouseOut: "naMouseOut", naMouseDown: "naMouseDown" } });
AMapOverlay.propDecorators = {
    cursor: [{ type: Input }],
    extData: [{ type: Input }],
    bubble: [{ type: Input }],
    clickable: [{ type: Input }],
    draggable: [{ type: Input }],
    naTouchStart: [{ type: Output }],
    naTouchMove: [{ type: Output }],
    naTouchEnd: [{ type: Output }],
    naClick: [{ type: Output }],
    naDblClick: [{ type: Output }],
    naRightClick: [{ type: Output }],
    naMouseOver: [{ type: Output }],
    naMouseUp: [{ type: Output }],
    naMouseOut: [{ type: Output }],
    naMouseDown: [{ type: Output }]
};

if (false) {
    /**
     * 鼠标悬停时的鼠标样式
     * @type {?}
     */
    AMapOverlay.prototype.cursor;
    /**
     * 自定义数据
     * @type {?}
     */
    AMapOverlay.prototype.extData;
    /**
     * 事件是否穿透到地图
     * @type {?}
     */
    AMapOverlay.prototype.bubble;
    /**
     * 是否支持点击
     * @type {?}
     */
    AMapOverlay.prototype.clickable;
    /**
     * 是否支持拖拽
     * @type {?}
     */
    AMapOverlay.prototype.draggable;
    /** @type {?} */
    AMapOverlay.prototype.naTouchStart;
    /** @type {?} */
    AMapOverlay.prototype.naTouchMove;
    /** @type {?} */
    AMapOverlay.prototype.naTouchEnd;
    /** @type {?} */
    AMapOverlay.prototype.naClick;
    /** @type {?} */
    AMapOverlay.prototype.naDblClick;
    /** @type {?} */
    AMapOverlay.prototype.naRightClick;
    /** @type {?} */
    AMapOverlay.prototype.naMouseOver;
    /** @type {?} */
    AMapOverlay.prototype.naMouseUp;
    /** @type {?} */
    AMapOverlay.prototype.naMouseOut;
    /** @type {?} */
    AMapOverlay.prototype.naMouseDown;
    /**
     * @type {?}
     * @protected
     */
    AMapOverlay.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AMapOverlay.prototype.binder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/pixel.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PixelService {
    constructor() { }
    /**
     * @param {?} options
     * @return {?}
     */
    create(options) {
        if (!options) {
            return null;
        }
        if (options instanceof AMap.Pixel) {
            return options;
        }
        if (Array.isArray(options)) {
            return new AMap.Pixel(options[0], options[1]);
        }
        return new AMap.Pixel(options.x || 0, options.y || 0, options.round);
    }
}
PixelService.ɵfac = function PixelService_Factory(t) { return new (t || PixelService)(); };
PixelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PixelService, factory: PixelService.ɵfac, providedIn: 'root' });
/** @nocollapse */
PixelService.ctorParameters = () => [];
/** @nocollapse */ PixelService.ngInjectableDef = ɵɵdefineInjectable({ factory: function PixelService_Factory() { return new PixelService(); }, token: PixelService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PixelService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: shared/size.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SizeService {
    constructor() { }
    /**
     * @param {?} options
     * @return {?}
     */
    create(options) {
        if (!options) {
            return null;
        }
        if (options instanceof AMap.Size || Array.isArray(options)) {
            return options;
        }
        if (options.width !== undefined && options.height !== undefined) {
            return new AMap.Size(options.width, options.height);
        }
        if (options.w !== undefined && options.h !== undefined) {
            return new AMap.Size(options.w, options.h);
        }
        return null;
    }
}
SizeService.ɵfac = function SizeService_Factory(t) { return new (t || SizeService)(); };
SizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SizeService, factory: SizeService.ɵfac, providedIn: 'root' });
/** @nocollapse */
SizeService.ctorParameters = () => [];
/** @nocollapse */ SizeService.ngInjectableDef = ɵɵdefineInjectable({ factory: function SizeService_Factory() { return new SizeService(); }, token: SizeService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SizeService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: shared/icon.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IconService {
    /**
     * @param {?} pixels
     * @param {?} sizes
     */
    constructor(pixels, sizes) {
        this.pixels = pixels;
        this.sizes = sizes;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    create(options) {
        if (!options) {
            return null;
        }
        if (typeof options === 'string') {
            return options;
        }
        if (options instanceof AMap.Icon) {
            return options;
        }
        /** @type {?} */
        const iconOption = {};
        const { size, image, imageOffset, imageSize } = options;
        if (size !== undefined) {
            iconOption.size = this.sizes.create(size);
        }
        if (image !== undefined) {
            iconOption.image = image;
        }
        if (imageOffset !== undefined) {
            iconOption.imageOffset = this.pixels.create(imageOffset);
        }
        if (imageSize !== undefined) {
            iconOption.imageSize = this.sizes.create(imageSize);
        }
        return new AMap.Icon(iconOption);
    }
}
IconService.ɵfac = function IconService_Factory(t) { return new (t || IconService)(ɵngcc0.ɵɵinject(PixelService), ɵngcc0.ɵɵinject(SizeService)); };
IconService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IconService, factory: IconService.ɵfac, providedIn: 'root' });
/** @nocollapse */
IconService.ctorParameters = () => [
    { type: PixelService },
    { type: SizeService }
];
/** @nocollapse */ IconService.ngInjectableDef = ɵɵdefineInjectable({ factory: function IconService_Factory() { return new IconService(ɵɵinject(PixelService), ɵɵinject(SizeService)); }, token: IconService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IconService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: PixelService }, { type: SizeService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    IconService.prototype.pixels;
    /**
     * @type {?}
     * @private
     */
    IconService.prototype.sizes;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/marker-label.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MarkerLabelService {
    /**
     * @param {?} pixel
     */
    constructor(pixel) {
        this.pixel = pixel;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    create(options) {
        if (options) {
            /** @type {?} */
            const label = {};
            if (options.content !== undefined) {
                label.content = options.content;
            }
            if (options.offset !== undefined) {
                if (options.offset instanceof AMap.Pixel) {
                    label.offset = options.offset;
                }
                else {
                    label.offset = this.pixel.create(options.offset);
                }
            }
            if (options.direction !== undefined) {
                label.direction = options.direction;
            }
            return label;
        }
        return null;
    }
}
MarkerLabelService.ɵfac = function MarkerLabelService_Factory(t) { return new (t || MarkerLabelService)(ɵngcc0.ɵɵinject(PixelService)); };
MarkerLabelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MarkerLabelService, factory: MarkerLabelService.ɵfac, providedIn: 'root' });
/** @nocollapse */
MarkerLabelService.ctorParameters = () => [
    { type: PixelService }
];
/** @nocollapse */ MarkerLabelService.ngInjectableDef = ɵɵdefineInjectable({ factory: function MarkerLabelService_Factory() { return new MarkerLabelService(ɵɵinject(PixelService)); }, token: MarkerLabelService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MarkerLabelService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: PixelService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    MarkerLabelService.prototype.pixel;
}

/**
 * @fileoverview added by tsickle
 * Generated from: components/amap-info-window/amap-info-window.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$6 = 'AmapInfoWindow';
class AmapInfoWindowService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, logger, ngZone) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.infoWindow$ = new ReplaySubject(1);
    }
    /**
     * 获取信息窗体
     * @return {?}
     */
    get() {
        return this.infoWindow$.asObservable();
    }
    /**
     * 创建 AMap.InfoWindow
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            this.map = m;
            this.infoWindow = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.InfoWindow(options)));
            this.logger.d(TAG$6, 'new InfoWindow created.');
            this.infoWindow$.next(this.infoWindow);
            this.infoWindow$.complete();
            return this.infoWindow;
        })));
    }
    /**
     * 销毁
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} w
         * @return {?}
         */
        w => {
            w.close();
            this.logger.d(TAG$6, 'InfoWindow destroyed.');
            this.infoWindow = null;
            this.map = null;
        }));
    }
    /**
     * 打开
     * @param {?=} position
     * @return {?}
     */
    open(position) {
        this.get().subscribe((/**
         * @param {?} w
         * @return {?}
         */
        w => w.open(this.map, position)));
    }
    /**
     * 在覆盖物上打开窗体
     * @param {?} marker
     * @return {?}
     */
    openOnMark(marker) {
        zip(marker, this.get()).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, w]) => {
            w.open(this.map, m.getPosition());
        }));
    }
    /**
     * 关闭
     * @return {?}
     */
    close() {
        this.get().subscribe((/**
         * @param {?} w
         * @return {?}
         */
        w => w.close()));
    }
}
AmapInfoWindowService.ɵfac = function AmapInfoWindowService_Factory(t) { return new (t || AmapInfoWindowService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapInfoWindowService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapInfoWindowService, factory: AmapInfoWindowService.ɵfac });
/** @nocollapse */
AmapInfoWindowService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapInfoWindowService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowService.prototype.map;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowService.prototype.infoWindow;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowService.prototype.infoWindow$;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: components/amap-info-window/amap-info-window.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$7 = 'amap-info-window';
/** @type {?} */
const ALL_OPTIONS$1 = [
    'isCustom',
    'autoMove',
    'closeWhenClickMap',
    'content',
    'size',
    'anchor',
    'offset',
    'position',
    'showShadow',
];
class AmapInfoWindowComponent {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} el
     * @param {?} logger
     * @param {?} pixels
     * @param {?} sizes
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, el, logger, pixels, sizes, ngZone) {
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.el = el;
        this.logger = logger;
        this.pixels = pixels;
        this.sizes = sizes;
        this.ngZone = ngZone;
        /**
         * 额外：是否开启
         */
        this.isOpen = false;
        // ---- Events ----
        this.naReady = new EventEmitter();
        this.isOpenChange = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        const w = this.os.get();
        this.naOpen = this.binder.bindEvent(w, 'open');
        this.naClose = this.binder.bindEvent(w, 'close');
        this.naChange = this.binder.bindEvent(w, 'change');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const iw = this.get();
        if (!this.inited) {
            this.amaps.get().subscribe((/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$7, 'initializing ...');
                // bind isOpenChange events:
                this.subscriptions = this.binder.bindEvent(iw, 'open').subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (!this.isOpen) {
                        this.isOpen = true;
                        this.isOpenChange.emit(true);
                    }
                }));
                this.subscriptions.add(this.binder.bindEvent(iw, 'close').subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.isOpen) {
                        this.isOpen = false;
                        this.isOpenChange.emit(false);
                    }
                })));
                this.content = this.content
                    ? this.content
                    : this.el.nativeElement.querySelector('.amap-info-window-content');
                /** @type {?} */
                const options = getOptions(this, ALL_OPTIONS$1);
                if (this.offset) {
                    options.offset = this.pixels.create(this.offset);
                }
                if (this.size) {
                    options.size = this.sizes.create(this.size);
                }
                this.logger.d(TAG$7, 'options:', options);
                this.os.create(options).subscribe((/**
                 * @param {?} m
                 * @return {?}
                 */
                m => {
                    this.ngZone.run((/**
                     * @return {?}
                     */
                    () => {
                        this.toggleOpen();
                        this.naReady.emit(m);
                    }));
                    this.logger.d(TAG$7, 'InfoWindow is ready.');
                }));
                this.inited = true;
            }));
        }
        else {
            filter.has('isOpen').subscribe((/**
             * @return {?}
             */
            () => this.toggleOpen()));
            zip(filter.has('content'), iw).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, w]) => w.setContent(v)));
            zip(filter.notEmpty('position'), iw).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, w]) => w.setPosition(v)));
            zip(filter.notEmpty('size'), iw).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, w]) => w.setSize(this.sizes.create(v))));
            zip(filter.notEmpty('anchor'), iw).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, w]) => w.setAnchor(v)));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        this.os.destroy();
    }
    /**
     * 获取已创建的 AMap.InfoWindow 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
    /**
     * 开关窗体
     * @return {?}
     */
    toggleOpen() {
        this.logger.d(TAG$7, 'toggle open');
        this.isOpen ? this.open() : this.close();
    }
    /**
     * 打开窗体
     * @return {?}
     */
    open() {
        if (this.hostMarker) {
            this.os.openOnMark(this.hostMarker);
        }
        else {
            this.os.open();
        }
    }
    /**
     * 关闭窗体
     * @return {?}
     */
    close() {
        this.os.close();
    }
}
AmapInfoWindowComponent.ɵfac = function AmapInfoWindowComponent_Factory(t) { return new (t || AmapInfoWindowComponent)(ɵngcc0.ɵɵdirectiveInject(AmapInfoWindowService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(SizeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapInfoWindowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AmapInfoWindowComponent, selectors: [["amap-info-window"]], inputs: { isOpen: "isOpen", content: "content", isCustom: "isCustom", autoMove: "autoMove", closeWhenClickMap: "closeWhenClickMap", size: "size", anchor: "anchor", offset: "offset", position: "position", showShadow: "showShadow" }, outputs: { naReady: "naReady", isOpenChange: "isOpenChange", naOpen: "naOpen", naClose: "naClose", naChange: "naChange" }, features: [ɵngcc0.ɵɵProvidersFeature([AmapInfoWindowService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 0, consts: [[1, "amap-info-window-inner"], [1, "amap-info-window-content"]], template: function AmapInfoWindowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [""] });
/** @nocollapse */
AmapInfoWindowComponent.ctorParameters = () => [
    { type: AmapInfoWindowService },
    { type: EventBinderService },
    { type: AMapService },
    { type: ElementRef },
    { type: LoggerService },
    { type: PixelService },
    { type: SizeService },
    { type: NgZone }
];
AmapInfoWindowComponent.propDecorators = {
    isCustom: [{ type: Input }],
    autoMove: [{ type: Input }],
    closeWhenClickMap: [{ type: Input }],
    content: [{ type: Input }],
    size: [{ type: Input }],
    anchor: [{ type: Input }],
    offset: [{ type: Input }],
    position: [{ type: Input }],
    showShadow: [{ type: Input }],
    isOpen: [{ type: Input }],
    naReady: [{ type: Output }],
    naOpen: [{ type: Output }],
    naClose: [{ type: Output }],
    naChange: [{ type: Output }],
    isOpenChange: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapInfoWindowComponent, [{
        type: Component,
        args: [{
                selector: 'amap-info-window',
                template: "<div class='amap-info-window-inner'></div>\n<div class='amap-info-window-content'>\n  <ng-content></ng-content>\n</div>",
                providers: [AmapInfoWindowService],
                styles: [""]
            }]
    }], function () { return [{ type: AmapInfoWindowService }, { type: EventBinderService }, { type: AMapService }, { type: ɵngcc0.ElementRef }, { type: LoggerService }, { type: PixelService }, { type: SizeService }, { type: ɵngcc0.NgZone }]; }, { isOpen: [{
            type: Input
        }], naReady: [{
            type: Output
        }], isOpenChange: [{
            type: Output
        }], naOpen: [{
            type: Output
        }], naClose: [{
            type: Output
        }], naChange: [{
            type: Output
        }], content: [{
            type: Input
        }], isCustom: [{
            type: Input
        }], autoMove: [{
            type: Input
        }], closeWhenClickMap: [{
            type: Input
        }], size: [{
            type: Input
        }], anchor: [{
            type: Input
        }], offset: [{
            type: Input
        }], position: [{
            type: Input
        }], showShadow: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 是否自定义窗体
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.isCustom;
    /**
     * 是否自动调整窗体到视野内
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.autoMove;
    /**
     * 控制是否在鼠标点击地图后关闭信息窗体
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.closeWhenClickMap;
    /**
     * 显示内容
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.content;
    /**
     * 信息窗体尺寸
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.size;
    /**
     * 信息窗体锚点
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.anchor;
    /**
     * 信息窗体显示位置偏移量
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.offset;
    /**
     * 信息窗体显示基点位置
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.position;
    /**
     * 是否显示信息窗体阴影
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.showShadow;
    /**
     * 额外：是否开启
     * @type {?}
     */
    AmapInfoWindowComponent.prototype.isOpen;
    /** @type {?} */
    AmapInfoWindowComponent.prototype.naReady;
    /** @type {?} */
    AmapInfoWindowComponent.prototype.naOpen;
    /** @type {?} */
    AmapInfoWindowComponent.prototype.naClose;
    /** @type {?} */
    AmapInfoWindowComponent.prototype.naChange;
    /** @type {?} */
    AmapInfoWindowComponent.prototype.isOpenChange;
    /** @type {?} */
    AmapInfoWindowComponent.prototype.hostMarker;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.inited;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.subscriptions;
    /**
     * @type {?}
     * @protected
     */
    AmapInfoWindowComponent.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapInfoWindowComponent.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.pixels;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.sizes;
    /**
     * @type {?}
     * @private
     */
    AmapInfoWindowComponent.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-marker/amap-marker.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$8 = 'amap-marker';
/** @type {?} */
const ALL_OPTIONS$2 = [
    ...OverlayOptions,
    'position',
    'anchor',
    'offset',
    'icon',
    'content',
    'topWhenClick',
    'raiseOnDrag',
    'visible',
    'zIndex',
    'angle',
    'autoRotation',
    'animation',
    'shadow',
    'title',
    'shape',
    'label',
];
class AmapMarkerDirective extends AMapOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} pixels
     * @param {?} icons
     * @param {?} mlabels
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, pixels, icons, mlabels, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.pixels = pixels;
        this.icons = icons;
        this.mlabels = mlabels;
        this.logger = logger;
        this.ngZone = ngZone;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否包含在点聚合中
         */
        this.inCluster = false;
        /**
         * 额外: 点击时是否显示信息窗体
         */
        this.openInfoWindow = true;
        // amap-marker events:
        this.naReady = new EventEmitter();
        // amap info window:
        this.infoWindowComponent = new QueryList();
        this.inited = false;
        /** @type {?} */
        const target = this.os.get();
        this.naMouseOut = this.binder.bindEvent(target, 'mouseout');
        this.naDragStart = this.binder.bindEvent(target, 'dragstart');
        this.naDragging = this.binder.bindEvent(target, 'dragging');
        this.naDragEnd = this.binder.bindEvent(target, 'dragend');
        this.naMoving = this.binder.bindEvent(target, 'moving');
        this.naMoveEnd = this.binder.bindEvent(target, 'moveend');
        this.naMoveAlong = this.binder.bindEvent(target, 'movealong');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const marker = this.get();
        if (!this.inited) {
            // do not draw marker when no poistion defined.
            if (!this.position) {
                return;
            }
            this.amaps.get().subscribe((/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$8, 'initializing ...');
                // bind info window events:
                this.subscription = this.binder.bindEvent(marker, 'click').subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.openInfoWindow) {
                        this.infoWindowComponent.forEach((/**
                         * @param {?} w
                         * @return {?}
                         */
                        w => w.open()));
                    }
                }));
                /** @type {?} */
                const options = getOptions(this, ALL_OPTIONS$2);
                if (this.icon) {
                    options.icon = this.icons.create(this.icon);
                }
                if (this.shadow) {
                    options.shadow = this.icons.create(this.shadow);
                }
                if (this.label) {
                    options.label = this.mlabels.create(this.label);
                }
                if (this.offset) {
                    options.offset = this.pixels.create(this.offset);
                }
                this.logger.d(TAG$8, 'options:', options);
                this.os.create(options, !this.inCluster).subscribe((/**
                 * @param {?} m
                 * @return {?}
                 */
                m => {
                    this.ngZone.run((/**
                     * @return {?}
                     */
                    () => this.naReady.emit(m)));
                    this.logger.d(TAG$8, 'marker is ready.');
                }));
                this.inited = true;
                this.updateInfoWindow();
                this.updateInfoWindowPosition();
            }));
        }
        else {
            zip(filter.has('icon'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setIcon(this.icons.create(v))));
            zip(filter.has('shadow'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setShadow(this.icons.create(v))));
            zip(filter.has('label'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setLabel(this.mlabels.create(v))));
            zip(filter.has('title'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setTitle(v)));
            zip(filter.has('content'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setContent(v)));
            zip(filter.has('extData'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setExtData(v)));
            zip(filter.has('clickable'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setClickable(!!v)));
            zip(filter.has('draggable'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setDraggable(!!v)));
            zip(filter.has('visible'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => (v ? m.show() : m.hide())));
            zip(filter.has('cursor'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setCursor(v)));
            zip(filter.has('animation'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAnimation(v)));
            zip(filter.has('angle'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAngle(v)));
            zip(filter.has('zIndex'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setzIndex(v)));
            zip(filter.has('shape'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setShape(v)));
            zip(filter.notEmpty('offset'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setOffset(this.pixels.create(v))));
            zip(filter.notEmpty('position'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setPosition(v)));
        }
        zip(filter.has('isTop'), marker).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => m.setTop(!!v)));
        zip(filter.has('hidden'), marker).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => (v ? m.hide() : m.show())));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateInfoWindow();
        this.infoWindowComponent.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateInfoWindow()));
    }
    /**
     * @private
     * @return {?}
     */
    updateInfoWindow() {
        if (this.infoWindowComponent && this.inited) {
            if (this.infoWindowComponent.length > 1) {
                this.logger.e(TAG$8, 'Expected no more than 1 info window.');
                return;
            }
            /** @type {?} */
            const marker = this.os.get();
            this.infoWindowComponent.forEach((/**
             * @param {?} component
             * @return {?}
             */
            component => {
                component.hostMarker = marker;
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInfoWindowPosition() {
        if (this.infoWindowComponent && this.inited) {
            this.infoWindowComponent.forEach((/**
             * @param {?} component
             * @return {?}
             */
            component => {
                component.toggleOpen();
            }));
        }
    }
    /**
     * 获取已创建的 AMap.Marker 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapMarkerDirective.ɵfac = function AmapMarkerDirective_Factory(t) { return new (t || AmapMarkerDirective)(ɵngcc0.ɵɵdirectiveInject(AmapMarkerService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(IconService), ɵngcc0.ɵɵdirectiveInject(MarkerLabelService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapMarkerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapMarkerDirective, selectors: [["amap-marker"]], contentQueries: function AmapMarkerDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AmapInfoWindowComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.infoWindowComponent = _t);
    } }, inputs: { hidden: "hidden", inCluster: "inCluster", openInfoWindow: "openInfoWindow", position: "position", anchor: "anchor", offset: "offset", icon: "icon", content: "content", topWhenClick: "topWhenClick", raiseOnDrag: "raiseOnDrag", visible: "visible", zIndex: "zIndex", angle: "angle", autoRotation: "autoRotation", animation: "animation", shadow: "shadow", title: "title", shape: "shape", label: "label", isTop: "isTop" }, outputs: { naReady: "naReady", naMouseOut: "naMouseOut", naDragStart: "naDragStart", naDragging: "naDragging", naDragEnd: "naDragEnd", naMoving: "naMoving", naMoveEnd: "naMoveEnd", naMoveAlong: "naMoveAlong" }, exportAs: ["marker"], features: [ɵngcc0.ɵɵProvidersFeature([AmapMarkerService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapMarkerDirective.ctorParameters = () => [
    { type: AmapMarkerService },
    { type: EventBinderService },
    { type: AMapService },
    { type: PixelService },
    { type: IconService },
    { type: MarkerLabelService },
    { type: LoggerService },
    { type: NgZone }
];
AmapMarkerDirective.propDecorators = {
    position: [{ type: Input }],
    anchor: [{ type: Input }],
    offset: [{ type: Input }],
    icon: [{ type: Input }],
    content: [{ type: Input }],
    topWhenClick: [{ type: Input }],
    raiseOnDrag: [{ type: Input }],
    visible: [{ type: Input }],
    zIndex: [{ type: Input }],
    angle: [{ type: Input }],
    autoRotation: [{ type: Input }],
    animation: [{ type: Input }],
    shadow: [{ type: Input }],
    title: [{ type: Input }],
    shape: [{ type: Input }],
    label: [{ type: Input }],
    isTop: [{ type: Input }],
    hidden: [{ type: Input }],
    inCluster: [{ type: Input }],
    openInfoWindow: [{ type: Input }],
    naReady: [{ type: Output }],
    naMouseOut: [{ type: Output }],
    naDragStart: [{ type: Output }],
    naDragging: [{ type: Output }],
    naDragEnd: [{ type: Output }],
    naMoving: [{ type: Output }],
    naMoveEnd: [{ type: Output }],
    naMoveAlong: [{ type: Output }],
    infoWindowComponent: [{ type: ContentChildren, args: [AmapInfoWindowComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapMarkerDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-marker',
                exportAs: 'marker',
                providers: [AmapMarkerService]
            }]
    }], function () { return [{ type: AmapMarkerService }, { type: EventBinderService }, { type: AMapService }, { type: PixelService }, { type: IconService }, { type: MarkerLabelService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { hidden: [{
            type: Input
        }], inCluster: [{
            type: Input
        }], openInfoWindow: [{
            type: Input
        }], naReady: [{
            type: Output
        }], infoWindowComponent: [{
            type: ContentChildren,
            args: [AmapInfoWindowComponent]
        }], naMouseOut: [{
            type: Output
        }], naDragStart: [{
            type: Output
        }], naDragging: [{
            type: Output
        }], naDragEnd: [{
            type: Output
        }], naMoving: [{
            type: Output
        }], naMoveEnd: [{
            type: Output
        }], naMoveAlong: [{
            type: Output
        }], position: [{
            type: Input
        }], anchor: [{
            type: Input
        }], offset: [{
            type: Input
        }], icon: [{
            type: Input
        }], content: [{
            type: Input
        }], topWhenClick: [{
            type: Input
        }], raiseOnDrag: [{
            type: Input
        }], visible: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], angle: [{
            type: Input
        }], autoRotation: [{
            type: Input
        }], animation: [{
            type: Input
        }], shadow: [{
            type: Input
        }], title: [{
            type: Input
        }], shape: [{
            type: Input
        }], label: [{
            type: Input
        }], isTop: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 点标记在地图上显示的位置
     * @type {?}
     */
    AmapMarkerDirective.prototype.position;
    /**
     * 标记锚点
     * @type {?}
     */
    AmapMarkerDirective.prototype.anchor;
    /**
     * 点标记显示位置偏移量
     * @type {?}
     */
    AmapMarkerDirective.prototype.offset;
    /**
     * 需在点标记中显示的图标
     * @type {?}
     */
    AmapMarkerDirective.prototype.icon;
    /**
     * 点标记显示内容
     * @type {?}
     */
    AmapMarkerDirective.prototype.content;
    /**
     * 鼠标点击时marker是否置顶
     * @type {?}
     */
    AmapMarkerDirective.prototype.topWhenClick;
    /**
     * 拖拽点标记时是否开启点标记离开地图的效果
     * @type {?}
     */
    AmapMarkerDirective.prototype.raiseOnDrag;
    /**
     * 点标记是否可见
     * @type {?}
     */
    AmapMarkerDirective.prototype.visible;
    /**
     * 点标记的叠加顺序
     * @type {?}
     */
    AmapMarkerDirective.prototype.zIndex;
    /**
     * 点标记的旋转角度
     * @type {?}
     */
    AmapMarkerDirective.prototype.angle;
    /**
     * 是否自动旋转
     * @type {?}
     */
    AmapMarkerDirective.prototype.autoRotation;
    /**
     * 点标记的动画效果
     * @type {?}
     */
    AmapMarkerDirective.prototype.animation;
    /**
     * 点标记阴影
     * @type {?}
     */
    AmapMarkerDirective.prototype.shadow;
    /**
     * 鼠标滑过点标记时的文字提示
     * @type {?}
     */
    AmapMarkerDirective.prototype.title;
    /**
     * 可点击区域
     * @type {?}
     */
    AmapMarkerDirective.prototype.shape;
    /**
     * 文本标注
     * @type {?}
     */
    AmapMarkerDirective.prototype.label;
    /**
     * 额外: 是否置顶
     * @type {?}
     */
    AmapMarkerDirective.prototype.isTop;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AmapMarkerDirective.prototype.hidden;
    /**
     * 额外: 是否包含在点聚合中
     * @type {?}
     */
    AmapMarkerDirective.prototype.inCluster;
    /**
     * 额外: 点击时是否显示信息窗体
     * @type {?}
     */
    AmapMarkerDirective.prototype.openInfoWindow;
    /** @type {?} */
    AmapMarkerDirective.prototype.naReady;
    /** @type {?} */
    AmapMarkerDirective.prototype.naMouseOut;
    /** @type {?} */
    AmapMarkerDirective.prototype.naDragStart;
    /** @type {?} */
    AmapMarkerDirective.prototype.naDragging;
    /** @type {?} */
    AmapMarkerDirective.prototype.naDragEnd;
    /** @type {?} */
    AmapMarkerDirective.prototype.naMoving;
    /** @type {?} */
    AmapMarkerDirective.prototype.naMoveEnd;
    /** @type {?} */
    AmapMarkerDirective.prototype.naMoveAlong;
    /** @type {?} */
    AmapMarkerDirective.prototype.infoWindowComponent;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.inited;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.subscription;
    /**
     * @type {?}
     * @protected
     */
    AmapMarkerDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapMarkerDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.pixels;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.icons;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.mlabels;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: base/amap-shape-overlay.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class AMapShapeOverlay extends AMapOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     */
    constructor(os, binder) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        /** @type {?} */
        const target = os.get();
        this.naShow = this.binder.bindEvent(target, 'show');
        this.naHide = this.binder.bindEvent(target, 'hide');
        this.naChange = this.binder.bindEvent(target, 'change');
    }
}
AMapShapeOverlay.ɵfac = function AMapShapeOverlay_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AMapShapeOverlay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AMapShapeOverlay, outputs: { naShow: "naShow", naHide: "naHide", naChange: "naChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
AMapShapeOverlay.propDecorators = {
    naShow: [{ type: Output }],
    naHide: [{ type: Output }],
    naChange: [{ type: Output }]
};

if (false) {
    /** @type {?} */
    AMapShapeOverlay.prototype.naShow;
    /** @type {?} */
    AMapShapeOverlay.prototype.naHide;
    /** @type {?} */
    AMapShapeOverlay.prototype.naChange;
    /**
     * @type {?}
     * @protected
     */
    AMapShapeOverlay.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AMapShapeOverlay.prototype.binder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: base/amap-path-overlay.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PathOverlayOptions = [
    ...OverlayOptions,
    'visible',
    'zIndex',
    'strokeColor',
    'strokeOpacity',
    'strokeWeight',
    'strokeStyle',
    'strokeDasharray',
    'lineJoin',
    'lineCap',
];
/**
 * @template T
 */
class AMapPathOverlay extends AMapShapeOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     */
    constructor(os, binder) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
    }
}
AMapPathOverlay.ɵfac = function AMapPathOverlay_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AMapPathOverlay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AMapPathOverlay, inputs: { visible: "visible", zIndex: "zIndex", strokeColor: "strokeColor", strokeOpacity: "strokeOpacity", strokeWeight: "strokeWeight", strokeStyle: "strokeStyle", strokeDasharray: "strokeDasharray", lineJoin: "lineJoin", lineCap: "lineCap" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
AMapPathOverlay.propDecorators = {
    visible: [{ type: Input }],
    zIndex: [{ type: Input }],
    strokeColor: [{ type: Input }],
    strokeOpacity: [{ type: Input }],
    strokeWeight: [{ type: Input }],
    strokeStyle: [{ type: Input }],
    strokeDasharray: [{ type: Input }],
    lineJoin: [{ type: Input }],
    lineCap: [{ type: Input }]
};

if (false) {
    /**
     * 是否可见
     * @type {?}
     */
    AMapPathOverlay.prototype.visible;
    /**
     * 覆盖物层级
     * @type {?}
     */
    AMapPathOverlay.prototype.zIndex;
    /**
     * 描边线条颜色
     * @type {?}
     */
    AMapPathOverlay.prototype.strokeColor;
    /**
     * 描边线条透明度
     * @type {?}
     */
    AMapPathOverlay.prototype.strokeOpacity;
    /**
     * 描边宽度
     * @type {?}
     */
    AMapPathOverlay.prototype.strokeWeight;
    /**
     * 描边样式
     * @type {?}
     */
    AMapPathOverlay.prototype.strokeStyle;
    /**
     * 虚线间隔
     * @type {?}
     */
    AMapPathOverlay.prototype.strokeDasharray;
    /**
     * 折线拐点的绘制样式
     * @type {?}
     */
    AMapPathOverlay.prototype.lineJoin;
    /**
     * 折线两端线帽的绘制样式
     * @type {?}
     */
    AMapPathOverlay.prototype.lineCap;
    /**
     * @type {?}
     * @protected
     */
    AMapPathOverlay.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AMapPathOverlay.prototype.binder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-polyline/amap-polyline.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$9 = 'AmapPolyline';
class AmapPolylineService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     * @param {?} plugins
     */
    constructor(amaps, logger, ngZone, plugins) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.plugins = plugins;
        this.polyline$ = new ReplaySubject(1);
        this.editor$ = new ReplaySubject(1);
    }
    /**
     * 获取折线
     * @return {?}
     */
    get() {
        return this.polyline$.asObservable();
    }
    /**
     * 创建折线 AMap.Polyline
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.polyline = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Polyline(options)));
            this.logger.d(TAG$9, 'new Polyline created.');
            this.polyline$.next(this.polyline);
            this.polyline$.complete();
            return this.polyline;
        })));
    }
    /**
     * 销毁折线
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$9, 'Polyline destroyed.');
            this.polyline = null;
        }));
    }
    /**
     * @return {?}
     */
    getEditor() {
        // plugin is loading:
        return this.editor$.asObservable();
    }
    /**
     * 加载编辑插件
     * @return {?}
     */
    loadEditor() {
        return this.plugins.load('AMap.PolyEditor');
    }
    /**
     * 创建编辑器
     * @return {?}
     */
    createEditor() {
        return this.loadEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.editor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.PolyEditor(m, p)));
            this.logger.d(TAG$9, 'new PolyEditor created.');
            this.editor$.next(this.editor);
            this.editor$.complete();
            return this.editor;
        })));
    }
    /**
     * 开关编辑器
     * @param {?} v 开关选项
     * @return {?}
     */
    toggleEditor(v) {
        if (v && !this.editor) {
            this.createEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.editor) {
            if (v) {
                this.editor.open();
            }
            else {
                this.editor.close();
            }
        }
    }
}
AmapPolylineService.ɵfac = function AmapPolylineService_Factory(t) { return new (t || AmapPolylineService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PluginLoaderService)); };
AmapPolylineService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapPolylineService, factory: AmapPolylineService.ɵfac });
/** @nocollapse */
AmapPolylineService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone },
    { type: PluginLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapPolylineService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }, { type: PluginLoaderService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.polyline;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.polyline$;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.editor;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.editor$;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineService.prototype.plugins;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-polyline/amap-polyline.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$a = 'amap-polyline';
/** @type {?} */
const PolylineOptions = [
    ...PathOverlayOptions,
    'isOutline',
    'outlineColor',
    'geodesic',
    'dirColor',
    'borderWeight',
    'showDir',
    'path',
];
class AmapPolylineDirective extends AMapPathOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否开启编辑器
         */
        this.editor = false;
        // directive events:
        this.naReady = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        const editor = this.os.getEditor();
        this.naEditorAddNode = this.binder.bindEvent(editor, 'addnode');
        this.naEditorRemoveNode = this.binder.bindEvent(editor, 'removenode');
        this.naEditorAdjust = this.binder.bindEvent(editor, 'adjust');
        this.naEditorEnd = this.binder.bindEvent(editor, 'end');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const polyline = this.get();
        if (!this.inited) {
            this.logger.d(TAG$a, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, PolylineOptions);
            this.logger.d(TAG$a, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$a, 'polyline is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('path'), polyline).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setPath(v)));
            zip(filter.has('options'), polyline).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('extData'), polyline).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), polyline).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
        filter.has('editor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.toggleEditor(v)));
    }
    /**
     * 获取已创建的 AMap.Polyline 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapPolylineDirective.ɵfac = function AmapPolylineDirective_Factory(t) { return new (t || AmapPolylineDirective)(ɵngcc0.ɵɵdirectiveInject(AmapPolylineService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapPolylineDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapPolylineDirective, selectors: [["amap-polyline"]], inputs: { hidden: "hidden", editor: "editor", isOutline: "isOutline", outlineColor: "outlineColor", geodesic: "geodesic", dirColor: "dirColor", borderWeight: "borderWeight", showDir: "showDir", path: "path", options: "options" }, outputs: { naReady: "naReady", naEditorAddNode: "naEditorAddNode", naEditorRemoveNode: "naEditorRemoveNode", naEditorAdjust: "naEditorAdjust", naEditorEnd: "naEditorEnd" }, exportAs: ["polyline"], features: [ɵngcc0.ɵɵProvidersFeature([AmapPolylineService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapPolylineDirective.ctorParameters = () => [
    { type: AmapPolylineService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
AmapPolylineDirective.propDecorators = {
    isOutline: [{ type: Input }],
    outlineColor: [{ type: Input }],
    geodesic: [{ type: Input }],
    dirColor: [{ type: Input }],
    borderWeight: [{ type: Input }],
    showDir: [{ type: Input }],
    path: [{ type: Input }],
    hidden: [{ type: Input }],
    editor: [{ type: Input }],
    options: [{ type: Input }],
    naReady: [{ type: Output }],
    naEditorAddNode: [{ type: Output }],
    naEditorRemoveNode: [{ type: Output }],
    naEditorAdjust: [{ type: Output }],
    naEditorEnd: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapPolylineDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-polyline',
                exportAs: 'polyline',
                providers: [AmapPolylineService]
            }]
    }], function () { return [{ type: AmapPolylineService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { hidden: [{
            type: Input
        }], editor: [{
            type: Input
        }], naReady: [{
            type: Output
        }], naEditorAddNode: [{
            type: Output
        }], naEditorRemoveNode: [{
            type: Output
        }], naEditorAdjust: [{
            type: Output
        }], naEditorEnd: [{
            type: Output
        }], isOutline: [{
            type: Input
        }], outlineColor: [{
            type: Input
        }], geodesic: [{
            type: Input
        }], dirColor: [{
            type: Input
        }], borderWeight: [{
            type: Input
        }], showDir: [{
            type: Input
        }], path: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 线条是否带描边
     * @type {?}
     */
    AmapPolylineDirective.prototype.isOutline;
    /**
     * 线条描边颜色
     * @type {?}
     */
    AmapPolylineDirective.prototype.outlineColor;
    /**
     * 是否绘制成大地线
     * @type {?}
     */
    AmapPolylineDirective.prototype.geodesic;
    /**
     * 方向箭头颜色
     * @type {?}
     */
    AmapPolylineDirective.prototype.dirColor;
    /**
     * 描边的宽度
     * @type {?}
     */
    AmapPolylineDirective.prototype.borderWeight;
    /**
     * 是否延路径显示方向箭头
     * @type {?}
     */
    AmapPolylineDirective.prototype.showDir;
    /**
     * 折线的节点数组
     * @type {?}
     */
    AmapPolylineDirective.prototype.path;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AmapPolylineDirective.prototype.hidden;
    /**
     * 额外: 是否开启编辑器
     * @type {?}
     */
    AmapPolylineDirective.prototype.editor;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AmapPolylineDirective.prototype.options;
    /** @type {?} */
    AmapPolylineDirective.prototype.naReady;
    /** @type {?} */
    AmapPolylineDirective.prototype.naEditorAddNode;
    /** @type {?} */
    AmapPolylineDirective.prototype.naEditorRemoveNode;
    /** @type {?} */
    AmapPolylineDirective.prototype.naEditorAdjust;
    /** @type {?} */
    AmapPolylineDirective.prototype.naEditorEnd;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapPolylineDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapPolylineDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapPolylineDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: components/amap-text/amap-text.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$b = 'AmapText';
class AmapTextService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, logger, ngZone) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.text$ = new ReplaySubject(1);
    }
    /**
     * 获取点标记
     * @return {?}
     */
    get() {
        return this.text$.asObservable();
    }
    /**
     * 创建点标记 AMap.Text
     * @param {?} options 选项
     * @param {?=} addToMap 是否直接加进地图
     * @return {?}
     */
    create(options, addToMap = true) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            if (addToMap) {
                options.map = m;
            }
            this.text = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Text(options)));
            this.logger.d(TAG$b, 'new text created.');
            this.text$.next(this.text);
            this.text$.complete();
            return this.text;
        })));
    }
    /**
     * 销毁点标记
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$b, 'text destroyed.');
            this.text = null;
        }));
    }
}
AmapTextService.ɵfac = function AmapTextService_Factory(t) { return new (t || AmapTextService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapTextService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapTextService, factory: AmapTextService.ɵfac });
/** @nocollapse */
AmapTextService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapTextService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapTextService.prototype.text;
    /**
     * @type {?}
     * @private
     */
    AmapTextService.prototype.text$;
    /**
     * @type {?}
     * @private
     */
    AmapTextService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapTextService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapTextService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: components/amap-text/amap-text.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$c = 'amap-text';
/** @type {?} */
const ALL_OPTIONS$3 = [
    ...OverlayOptions,
    'text',
    'position',
    'anchor',
    'offset',
    'topWhenClick',
    'raiseOnDrag',
    'visible',
    'zIndex',
    'angle',
    'autoRotation',
    'animation',
    'shadow',
    'title',
    'style',
];
class AmapTextComponent extends AMapOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} el
     * @param {?} pixels
     * @param {?} icons
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, el, pixels, icons, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.el = el;
        this.pixels = pixels;
        this.icons = icons;
        this.logger = logger;
        this.ngZone = ngZone;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否包含在点聚合中
         */
        this.inCluster = false;
        /**
         * 额外: 点击时是否显示信息窗体
         */
        this.openInfoWindow = true;
        // ---- Events ----
        this.naReady = new EventEmitter();
        // amap info window:
        this.infoWindowComponent = new QueryList();
        this.inited = false;
        /** @type {?} */
        const target = this.os.get();
        this.naMouseOut = this.binder.bindEvent(target, 'mouseout');
        this.naDragStart = this.binder.bindEvent(target, 'dragstart');
        this.naDragging = this.binder.bindEvent(target, 'dragging');
        this.naDragEnd = this.binder.bindEvent(target, 'dragend');
        this.naMoving = this.binder.bindEvent(target, 'moving');
        this.naMoveEnd = this.binder.bindEvent(target, 'moveend');
        this.naMoveAlong = this.binder.bindEvent(target, 'movealong');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const marker = this.get();
        if (!this.inited) {
            // do not draw text marker when no poistion defined.
            if (!this.position) {
                return;
            }
            this.amaps.get().subscribe((/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$c, 'initializing ...');
                // bind info window events:
                this.subscription = this.binder.bindEvent(marker, 'click').subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.openInfoWindow) {
                        this.infoWindowComponent.forEach((/**
                         * @param {?} w
                         * @return {?}
                         */
                        w => w.open()));
                    }
                }));
                /** @type {?} */
                const el = this.el.nativeElement.querySelector('.amap-text-content');
                this.text = this.text ? this.text : el.innerText;
                /** @type {?} */
                const options = getOptions(this, ALL_OPTIONS$3);
                if (this.shadow) {
                    options.shadow = this.icons.create(this.shadow);
                }
                if (this.offset) {
                    options.offset = this.pixels.create(this.offset);
                }
                this.logger.d(TAG$c, 'options:', options);
                this.os.create(options).subscribe((/**
                 * @param {?} m
                 * @return {?}
                 */
                m => {
                    this.ngZone.run((/**
                     * @return {?}
                     */
                    () => this.naReady.emit(m)));
                    this.logger.d(TAG$c, 'marker is ready.');
                }));
                this.inited = true;
                this.updateInfoWindow();
                this.updateInfoWindowPosition();
            }));
        }
        else {
            zip(filter.has('shadow'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setShadow(this.icons.create(v))));
            zip(filter.has('offset'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setOffset(this.pixels.create(v))));
            zip(filter.has('title'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setTitle(v)));
            zip(filter.has('content'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setContent(v)));
            zip(filter.has('extData'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setExtData(v)));
            zip(filter.has('clickable'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setClickable(!!v)));
            zip(filter.has('draggable'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setDraggable(!!v)));
            zip(filter.has('visible'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => (v ? m.show() : m.hide())));
            zip(filter.has('cursor'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setCursor(v)));
            zip(filter.has('animation'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAnimation(v)));
            zip(filter.has('angle'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAngle(v)));
            zip(filter.has('zIndex'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setzIndex(v)));
            zip(filter.notEmpty('position'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setPosition(v)));
            zip(filter.notEmpty('style'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setStyle(v)));
        }
        zip(filter.has('isTop'), marker).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => m.setTop(!!v)));
        zip(filter.has('hidden'), marker).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => (v ? m.hide() : m.show())));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateInfoWindow();
        this.infoWindowComponent.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateInfoWindow()));
    }
    /**
     * @private
     * @return {?}
     */
    updateInfoWindow() {
        if (this.infoWindowComponent && this.inited) {
            if (this.infoWindowComponent.length > 1) {
                this.logger.e(TAG$c, 'Expected no more than 1 info window.');
                return;
            }
            /** @type {?} */
            const marker = this.os.get();
            this.infoWindowComponent.forEach((/**
             * @param {?} component
             * @return {?}
             */
            component => {
                component.hostMarker = marker;
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInfoWindowPosition() {
        if (this.infoWindowComponent && this.inited) {
            this.infoWindowComponent.forEach((/**
             * @param {?} component
             * @return {?}
             */
            component => {
                component.toggleOpen();
            }));
        }
    }
    /**
     * 获取已创建的 AMap.Text 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapTextComponent.ɵfac = function AmapTextComponent_Factory(t) { return new (t || AmapTextComponent)(ɵngcc0.ɵɵdirectiveInject(AmapTextService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(IconService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapTextComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AmapTextComponent, selectors: [["amap-text"]], contentQueries: function AmapTextComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AmapInfoWindowComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.infoWindowComponent = _t);
    } }, inputs: { hidden: "hidden", inCluster: "inCluster", openInfoWindow: "openInfoWindow", text: "text", position: "position", anchor: "anchor", offset: "offset", topWhenClick: "topWhenClick", raiseOnDrag: "raiseOnDrag", visible: "visible", zIndex: "zIndex", angle: "angle", autoRotation: "autoRotation", animation: "animation", shadow: "shadow", title: "title", style: "style", isTop: "isTop" }, outputs: { naReady: "naReady", naMouseOut: "naMouseOut", naDragStart: "naDragStart", naDragging: "naDragging", naDragEnd: "naDragEnd", naMoving: "naMoving", naMoveEnd: "naMoveEnd", naMoveAlong: "naMoveAlong" }, exportAs: ["text"], features: [ɵngcc0.ɵɵProvidersFeature([AmapTextService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 0, consts: [[1, "amap-text-inner"], [1, "amap-text-content"]], template: function AmapTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/** @nocollapse */
AmapTextComponent.ctorParameters = () => [
    { type: AmapTextService },
    { type: EventBinderService },
    { type: AMapService },
    { type: ElementRef },
    { type: PixelService },
    { type: IconService },
    { type: LoggerService },
    { type: NgZone }
];
AmapTextComponent.propDecorators = {
    text: [{ type: Input }],
    position: [{ type: Input }],
    anchor: [{ type: Input }],
    offset: [{ type: Input }],
    topWhenClick: [{ type: Input }],
    raiseOnDrag: [{ type: Input }],
    visible: [{ type: Input }],
    zIndex: [{ type: Input }],
    angle: [{ type: Input }],
    autoRotation: [{ type: Input }],
    animation: [{ type: Input }],
    shadow: [{ type: Input }],
    title: [{ type: Input }],
    style: [{ type: Input }],
    isTop: [{ type: Input }],
    hidden: [{ type: Input }],
    inCluster: [{ type: Input }],
    openInfoWindow: [{ type: Input }],
    naReady: [{ type: Output }],
    naMouseOut: [{ type: Output }],
    naDragStart: [{ type: Output }],
    naDragging: [{ type: Output }],
    naDragEnd: [{ type: Output }],
    naMoving: [{ type: Output }],
    naMoveEnd: [{ type: Output }],
    naMoveAlong: [{ type: Output }],
    infoWindowComponent: [{ type: ContentChildren, args: [AmapInfoWindowComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapTextComponent, [{
        type: Component,
        args: [{
                selector: 'amap-text',
                exportAs: 'text',
                template: "<div class='amap-text-inner'></div>\n<div class='amap-text-content'>\n  <ng-content></ng-content>\n</div>",
                providers: [AmapTextService]
            }]
    }], function () { return [{ type: AmapTextService }, { type: EventBinderService }, { type: AMapService }, { type: ɵngcc0.ElementRef }, { type: PixelService }, { type: IconService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { hidden: [{
            type: Input
        }], inCluster: [{
            type: Input
        }], openInfoWindow: [{
            type: Input
        }], naReady: [{
            type: Output
        }], infoWindowComponent: [{
            type: ContentChildren,
            args: [AmapInfoWindowComponent]
        }], naMouseOut: [{
            type: Output
        }], naDragStart: [{
            type: Output
        }], naDragging: [{
            type: Output
        }], naDragEnd: [{
            type: Output
        }], naMoving: [{
            type: Output
        }], naMoveEnd: [{
            type: Output
        }], naMoveAlong: [{
            type: Output
        }], text: [{
            type: Input
        }], position: [{
            type: Input
        }], anchor: [{
            type: Input
        }], offset: [{
            type: Input
        }], topWhenClick: [{
            type: Input
        }], raiseOnDrag: [{
            type: Input
        }], visible: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], angle: [{
            type: Input
        }], autoRotation: [{
            type: Input
        }], animation: [{
            type: Input
        }], shadow: [{
            type: Input
        }], title: [{
            type: Input
        }], style: [{
            type: Input
        }], isTop: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 点标记显示内容
     * @type {?}
     */
    AmapTextComponent.prototype.text;
    /**
     * 点标记在地图上显示的位置
     * @type {?}
     */
    AmapTextComponent.prototype.position;
    /**
     * 标记锚点
     * @type {?}
     */
    AmapTextComponent.prototype.anchor;
    /**
     * 点标记显示位置偏移量
     * @type {?}
     */
    AmapTextComponent.prototype.offset;
    /**
     * 鼠标点击时marker是否置顶
     * @type {?}
     */
    AmapTextComponent.prototype.topWhenClick;
    /**
     * 拖拽点标记时是否开启点标记离开地图的效果
     * @type {?}
     */
    AmapTextComponent.prototype.raiseOnDrag;
    /**
     * 点标记是否可见
     * @type {?}
     */
    AmapTextComponent.prototype.visible;
    /**
     * 点标记的叠加顺序
     * @type {?}
     */
    AmapTextComponent.prototype.zIndex;
    /**
     * 点标记的旋转角度
     * @type {?}
     */
    AmapTextComponent.prototype.angle;
    /**
     * 是否自动旋转
     * @type {?}
     */
    AmapTextComponent.prototype.autoRotation;
    /**
     * 点标记的动画效果
     * @type {?}
     */
    AmapTextComponent.prototype.animation;
    /**
     * 点标记阴影
     * @type {?}
     */
    AmapTextComponent.prototype.shadow;
    /**
     * 鼠标滑过点标记时的文字提示
     * @type {?}
     */
    AmapTextComponent.prototype.title;
    /**
     * 样式
     * @type {?}
     */
    AmapTextComponent.prototype.style;
    /**
     * 额外: 是否置顶
     * @type {?}
     */
    AmapTextComponent.prototype.isTop;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AmapTextComponent.prototype.hidden;
    /**
     * 额外: 是否包含在点聚合中
     * @type {?}
     */
    AmapTextComponent.prototype.inCluster;
    /**
     * 额外: 点击时是否显示信息窗体
     * @type {?}
     */
    AmapTextComponent.prototype.openInfoWindow;
    /** @type {?} */
    AmapTextComponent.prototype.naReady;
    /** @type {?} */
    AmapTextComponent.prototype.naMouseOut;
    /** @type {?} */
    AmapTextComponent.prototype.naDragStart;
    /** @type {?} */
    AmapTextComponent.prototype.naDragging;
    /** @type {?} */
    AmapTextComponent.prototype.naDragEnd;
    /** @type {?} */
    AmapTextComponent.prototype.naMoving;
    /** @type {?} */
    AmapTextComponent.prototype.naMoveEnd;
    /** @type {?} */
    AmapTextComponent.prototype.naMoveAlong;
    /** @type {?} */
    AmapTextComponent.prototype.infoWindowComponent;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.inited;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.subscription;
    /**
     * @type {?}
     * @protected
     */
    AmapTextComponent.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapTextComponent.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.pixels;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.icons;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapTextComponent.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: base/amap-polygon.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PolygonOptions = [...PathOverlayOptions, 'fillColor', 'fillOpacity', 'path'];
/**
 * @template T, E
 */
class AMapPolygon extends AMapPathOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     */
    constructor(os, binder) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否开启编辑器
         */
        this.editor = false;
        // directive events:
        this.naReady = new EventEmitter();
        /** @type {?} */
        const editor = this.os.getEditor();
        this.naEditorAddNode = this.binder.bindEvent(editor, 'addnode');
        this.naEditorRemoveNode = this.binder.bindEvent(editor, 'removenode');
        this.naEditorAdjust = this.binder.bindEvent(editor, 'adjust');
        this.naEditorEnd = this.binder.bindEvent(editor, 'end');
    }
}
AMapPolygon.ɵfac = function AMapPolygon_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AMapPolygon.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AMapPolygon, inputs: { hidden: "hidden", editor: "editor", path: "path", fillColor: "fillColor", fillOpacity: "fillOpacity", options: "options" }, outputs: { naReady: "naReady", naEditorAddNode: "naEditorAddNode", naEditorRemoveNode: "naEditorRemoveNode", naEditorAdjust: "naEditorAdjust", naEditorEnd: "naEditorEnd" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
AMapPolygon.propDecorators = {
    path: [{ type: Input }],
    fillColor: [{ type: Input }],
    fillOpacity: [{ type: Input }],
    hidden: [{ type: Input }],
    editor: [{ type: Input }],
    options: [{ type: Input }],
    naReady: [{ type: Output }],
    naEditorAddNode: [{ type: Output }],
    naEditorRemoveNode: [{ type: Output }],
    naEditorAdjust: [{ type: Output }],
    naEditorEnd: [{ type: Output }]
};

if (false) {
    /**
     * 多边形轮廓线的节点坐标数组
     * @type {?}
     */
    AMapPolygon.prototype.path;
    /**
     * 多边形填充颜色
     * @type {?}
     */
    AMapPolygon.prototype.fillColor;
    /**
     * 边形填充透明度
     * @type {?}
     */
    AMapPolygon.prototype.fillOpacity;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AMapPolygon.prototype.hidden;
    /**
     * 额外: 是否开启编辑器
     * @type {?}
     */
    AMapPolygon.prototype.editor;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AMapPolygon.prototype.options;
    /** @type {?} */
    AMapPolygon.prototype.naReady;
    /** @type {?} */
    AMapPolygon.prototype.naEditorAddNode;
    /** @type {?} */
    AMapPolygon.prototype.naEditorRemoveNode;
    /** @type {?} */
    AMapPolygon.prototype.naEditorAdjust;
    /** @type {?} */
    AMapPolygon.prototype.naEditorEnd;
    /**
     * @type {?}
     * @protected
     */
    AMapPolygon.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AMapPolygon.prototype.binder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-polygon/amap-polygon.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$d = 'AmapPolygon';
class AmapPolygonService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     * @param {?} plugins
     */
    constructor(amaps, logger, ngZone, plugins) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.plugins = plugins;
        this.polygon$ = new ReplaySubject(1);
        this.editor$ = new ReplaySubject(1);
    }
    /**
     * 获取折线
     * @return {?}
     */
    get() {
        return this.polygon$.asObservable();
    }
    /**
     * 创建折线 AMap.Polygon
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.polygon = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Polygon(options)));
            this.logger.d(TAG$d, 'new Polygon created.');
            this.polygon$.next(this.polygon);
            this.polygon$.complete();
            return this.polygon;
        })));
    }
    /**
     * 销毁折线
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$d, 'Polygon destroyed.');
            this.polygon = null;
        }));
    }
    /**
     * @return {?}
     */
    getEditor() {
        // plugin is loading:
        return this.editor$.asObservable();
    }
    /**
     * 加载编辑插件
     * @return {?}
     */
    loadEditor() {
        return this.plugins.load('AMap.PolyEditor');
    }
    /**
     * 创建编辑器
     * @return {?}
     */
    createEditor() {
        return this.loadEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.editor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.PolyEditor(m, p)));
            this.logger.d(TAG$d, 'new PolyEditor created.');
            this.editor$.next(this.editor);
            this.editor$.complete();
            return this.editor;
        })));
    }
    /**
     * 开关编辑器
     * @param {?} v 开关选项
     * @return {?}
     */
    toggleEditor(v) {
        if (v && !this.editor) {
            this.createEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.editor) {
            if (v) {
                this.editor.open();
            }
            else {
                this.editor.close();
            }
        }
    }
}
AmapPolygonService.ɵfac = function AmapPolygonService_Factory(t) { return new (t || AmapPolygonService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PluginLoaderService)); };
AmapPolygonService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapPolygonService, factory: AmapPolygonService.ɵfac });
/** @nocollapse */
AmapPolygonService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone },
    { type: PluginLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapPolygonService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }, { type: PluginLoaderService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.polygon;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.polygon$;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.editor;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.editor$;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonService.prototype.plugins;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-polygon/amap-polygon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$e = 'amap-polygon';
class AmapPolygonDirective extends AMapPolygon {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        this.inited = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const polygon = this.get();
        if (!this.inited) {
            this.logger.d(TAG$e, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, PolygonOptions);
            this.logger.d(TAG$e, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$e, 'polygon is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('path'), polygon).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setPath(v)));
            zip(filter.has('options'), polygon).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('extData'), polygon).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), polygon).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
        filter.has('editor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.toggleEditor(v)));
    }
    /**
     * 获取已创建的 AMap.Polygon 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapPolygonDirective.ɵfac = function AmapPolygonDirective_Factory(t) { return new (t || AmapPolygonDirective)(ɵngcc0.ɵɵdirectiveInject(AmapPolygonService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapPolygonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapPolygonDirective, selectors: [["amap-polygon"]], exportAs: ["polygon"], features: [ɵngcc0.ɵɵProvidersFeature([AmapPolygonService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapPolygonDirective.ctorParameters = () => [
    { type: AmapPolygonService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapPolygonDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-polygon',
                exportAs: 'polygon',
                providers: [AmapPolygonService]
            }]
    }], function () { return [{ type: AmapPolygonService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapPolygonDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapPolygonDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapPolygonDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapPolygonDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-bezier-curve/amap-bezier-curve.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$f = 'AmapBezierCurve';
class AmapBezierCurveService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     * @param {?} plugins
     */
    constructor(amaps, logger, ngZone, plugins) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.plugins = plugins;
        this.bezierCurve$ = new ReplaySubject(1);
        this.editor$ = new ReplaySubject(1);
        this.polyEditor$ = new ReplaySubject(1);
    }
    /**
     * 获取贝瑟尔曲线
     * @return {?}
     */
    get() {
        return this.bezierCurve$.asObservable();
    }
    /**
     * 创建贝瑟尔曲线 AMap.BezierCurve
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.bezierCurve = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.BezierCurve(options)));
            this.logger.d(TAG$f, 'new BezierCurve created.');
            this.bezierCurve$.next(this.bezierCurve);
            this.bezierCurve$.complete();
            return this.bezierCurve;
        })));
    }
    /**
     * 销毁贝瑟尔曲线
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$f, 'BezierCurve destroyed.');
            this.bezierCurve = null;
        }));
    }
    /**
     * @return {?}
     */
    getEditor() {
        // plugin is loading:
        return this.editor$.asObservable();
    }
    /**
     * @return {?}
     */
    getPolyEditor() {
        return this.polyEditor$.asObservable();
    }
    /**
     * 加载编辑插件
     * @return {?}
     */
    loadEditor() {
        return this.plugins.load('AMap.BezierCurveEditor');
    }
    /**
     * @return {?}
     */
    loadPolyEditor() {
        return this.plugins.load('AMap.PolyEditor');
    }
    /**
     * 创建编辑器
     * @return {?}
     */
    createEditor() {
        return this.loadEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.editor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.BezierCurveEditor(m, p)));
            this.logger.d(TAG$f, 'new BezierCurveEditor created.');
            this.editor$.next(this.editor);
            this.editor$.complete();
            return this.editor;
        })));
    }
    /**
     * @return {?}
     */
    createPolyEditor() {
        return this.loadPolyEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.polyEditor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.PolyEditor(m, p)));
            this.logger.d(TAG$f, 'new PolyEditor created.');
            this.polyEditor$.next(this.polyEditor);
            this.polyEditor$.complete();
            return this.polyEditor;
        })));
    }
    /**
     * 开关编辑器
     * @param {?} v 开关选项
     * @return {?}
     */
    toggleEditor(v) {
        if (v && !this.editor) {
            this.createEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.editor) {
            if (v) {
                this.editor.open();
            }
            else {
                this.editor.close();
            }
        }
    }
    /**
     * @param {?} v
     * @return {?}
     */
    togglePolyEditor(v) {
        if (v && !this.polyEditor) {
            this.createPolyEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.polyEditor) {
            if (v) {
                this.polyEditor.open();
            }
            else {
                this.polyEditor.close();
            }
        }
    }
}
AmapBezierCurveService.ɵfac = function AmapBezierCurveService_Factory(t) { return new (t || AmapBezierCurveService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PluginLoaderService)); };
AmapBezierCurveService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapBezierCurveService, factory: AmapBezierCurveService.ɵfac });
/** @nocollapse */
AmapBezierCurveService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone },
    { type: PluginLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapBezierCurveService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }, { type: PluginLoaderService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.bezierCurve;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.bezierCurve$;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.editor;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.editor$;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.polyEditor;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.polyEditor$;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveService.prototype.plugins;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-bezier-curve/amap-bezier-curve.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$g = 'amap-bezier-curve';
/** @type {?} */
const BezierCurveOptions = [
    ...PathOverlayOptions,
    'isOutline',
    'outlineColor',
    'dirColor',
    'borderWeight',
    'showDir',
    'path',
];
class AmapBezierCurveDirective extends AMapPathOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否开启曲线编辑器
         */
        this.editor = false;
        /**
         * 额外: 是否开启折线编辑器
         */
        this.polyEditor = false;
        // directive events:
        this.naReady = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        const editor = this.os.getEditor();
        /** @type {?} */
        const polyEditor = this.os.getPolyEditor();
        this.naEditorAddNode = this.binder.bindEvent(editor, 'addnode');
        this.naEditorRemoveNode = this.binder.bindEvent(editor, 'removenode');
        this.naEditorAdjust = this.binder.bindEvent(editor, 'adjust');
        this.naEditorEnd = this.binder.bindEvent(editor, 'end');
        this.naPolyEditorAddNode = this.binder.bindEvent(polyEditor, 'addnode');
        this.naPolyEditorRemoveNode = this.binder.bindEvent(polyEditor, 'removenode');
        this.naPolyEditorAdjust = this.binder.bindEvent(polyEditor, 'adjust');
        this.naPolyEditorEnd = this.binder.bindEvent(polyEditor, 'end');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const bezierCurve = this.get();
        if (!this.inited) {
            this.logger.d(TAG$g, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, BezierCurveOptions);
            this.logger.d(TAG$g, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$g, 'bezierCurve is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('path'), bezierCurve).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setPath(v)));
            zip(filter.has('options'), bezierCurve).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('extData'), bezierCurve).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), bezierCurve).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => v ? p.hide() : p.show()));
        filter.has('editor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.toggleEditor(v)));
        filter.has('polyEditor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.togglePolyEditor(v)));
    }
    /**
     * 获取已创建的 AMap.BezierCurve 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapBezierCurveDirective.ɵfac = function AmapBezierCurveDirective_Factory(t) { return new (t || AmapBezierCurveDirective)(ɵngcc0.ɵɵdirectiveInject(AmapBezierCurveService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapBezierCurveDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapBezierCurveDirective, selectors: [["amap-bezier-curve"]], inputs: { hidden: "hidden", editor: "editor", polyEditor: "polyEditor", isOutline: "isOutline", outlineColor: "outlineColor", dirColor: "dirColor", borderWeight: "borderWeight", showDir: "showDir", path: "path", options: "options" }, outputs: { naReady: "naReady", naEditorAddNode: "naEditorAddNode", naEditorRemoveNode: "naEditorRemoveNode", naEditorAdjust: "naEditorAdjust", naEditorEnd: "naEditorEnd", naPolyEditorAddNode: "naPolyEditorAddNode", naPolyEditorRemoveNode: "naPolyEditorRemoveNode", naPolyEditorAdjust: "naPolyEditorAdjust", naPolyEditorEnd: "naPolyEditorEnd" }, exportAs: ["bezier-curve"], features: [ɵngcc0.ɵɵProvidersFeature([AmapBezierCurveService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapBezierCurveDirective.ctorParameters = () => [
    { type: AmapBezierCurveService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
AmapBezierCurveDirective.propDecorators = {
    isOutline: [{ type: Input }],
    outlineColor: [{ type: Input }],
    dirColor: [{ type: Input }],
    borderWeight: [{ type: Input }],
    showDir: [{ type: Input }],
    path: [{ type: Input }],
    hidden: [{ type: Input }],
    editor: [{ type: Input }],
    polyEditor: [{ type: Input }],
    options: [{ type: Input }],
    naReady: [{ type: Output }],
    naEditorAddNode: [{ type: Output }],
    naEditorRemoveNode: [{ type: Output }],
    naEditorAdjust: [{ type: Output }],
    naEditorEnd: [{ type: Output }],
    naPolyEditorAddNode: [{ type: Output }],
    naPolyEditorRemoveNode: [{ type: Output }],
    naPolyEditorAdjust: [{ type: Output }],
    naPolyEditorEnd: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapBezierCurveDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-bezier-curve',
                exportAs: 'bezier-curve',
                providers: [AmapBezierCurveService]
            }]
    }], function () { return [{ type: AmapBezierCurveService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { hidden: [{
            type: Input
        }], editor: [{
            type: Input
        }], polyEditor: [{
            type: Input
        }], naReady: [{
            type: Output
        }], naEditorAddNode: [{
            type: Output
        }], naEditorRemoveNode: [{
            type: Output
        }], naEditorAdjust: [{
            type: Output
        }], naEditorEnd: [{
            type: Output
        }], naPolyEditorAddNode: [{
            type: Output
        }], naPolyEditorRemoveNode: [{
            type: Output
        }], naPolyEditorAdjust: [{
            type: Output
        }], naPolyEditorEnd: [{
            type: Output
        }], isOutline: [{
            type: Input
        }], outlineColor: [{
            type: Input
        }], dirColor: [{
            type: Input
        }], borderWeight: [{
            type: Input
        }], showDir: [{
            type: Input
        }], path: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 线条是否带描边
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.isOutline;
    /**
     * 线条描边颜色
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.outlineColor;
    /**
     * 方向箭头颜色
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.dirColor;
    /**
     * 描边的宽度
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.borderWeight;
    /**
     * 是否延路径显示方向箭头
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.showDir;
    /**
     * 贝瑟尔曲线的路径
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.path;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.hidden;
    /**
     * 额外: 是否开启曲线编辑器
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.editor;
    /**
     * 额外: 是否开启折线编辑器
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.polyEditor;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AmapBezierCurveDirective.prototype.options;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naReady;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naEditorAddNode;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naEditorRemoveNode;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naEditorAdjust;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naEditorEnd;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naPolyEditorAddNode;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naPolyEditorRemoveNode;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naPolyEditorAdjust;
    /** @type {?} */
    AmapBezierCurveDirective.prototype.naPolyEditorEnd;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapBezierCurveDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapBezierCurveDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapBezierCurveDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-rectangle/amap-rectangle.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$h = 'AmapRectangle';
class AmapRectangleService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     * @param {?} plugins
     */
    constructor(amaps, logger, ngZone, plugins) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.plugins = plugins;
        this.rectangle$ = new ReplaySubject(1);
        this.editor$ = new ReplaySubject(1);
    }
    /**
     * 获取矩形
     * @return {?}
     */
    get() {
        return this.rectangle$.asObservable();
    }
    /**
     * 创建矩形 AMap.Rectangle
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.rectangle = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Rectangle(options)));
            this.logger.d(TAG$h, 'new Rectangle created.');
            this.rectangle$.next(this.rectangle);
            this.rectangle$.complete();
            return this.rectangle;
        })));
    }
    /**
     * 销毁矩形
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$h, 'Rectangle destroyed.');
            this.rectangle = null;
        }));
    }
    /**
     * @return {?}
     */
    getEditor() {
        // plugin is loading:
        return this.editor$.asObservable();
    }
    /**
     * 加载编辑插件
     * @return {?}
     */
    loadEditor() {
        return this.plugins.load('AMap.RectangleEditor');
    }
    /**
     * 创建编辑器
     * @return {?}
     */
    createEditor() {
        return this.loadEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.editor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.RectangleEditor(m, p)));
            this.logger.d(TAG$h, 'new RectangleEditor created.');
            this.editor$.next(this.editor);
            this.editor$.complete();
            return this.editor;
        })));
    }
    /**
     * 开关编辑器
     * @param {?} v 开关选项
     * @return {?}
     */
    toggleEditor(v) {
        if (v && !this.editor) {
            this.createEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.editor) {
            if (v) {
                this.editor.open();
            }
            else {
                this.editor.close();
            }
        }
    }
}
AmapRectangleService.ɵfac = function AmapRectangleService_Factory(t) { return new (t || AmapRectangleService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PluginLoaderService)); };
AmapRectangleService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapRectangleService, factory: AmapRectangleService.ɵfac });
/** @nocollapse */
AmapRectangleService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone },
    { type: PluginLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapRectangleService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }, { type: PluginLoaderService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.rectangle;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.rectangle$;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.editor;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.editor$;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleService.prototype.plugins;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-rectangle/amap-rectangle.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$i = 'amap-rectangle';
/** @type {?} */
const RectangleOptions = [...PolygonOptions, 'bounds'];
class AmapRectangleDirective extends AMapPolygon {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        this.inited = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const rectangle = this.get();
        if (!this.inited) {
            this.logger.d(TAG$i, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, RectangleOptions);
            this.logger.d(TAG$i, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$i, 'rectangle is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('path'), rectangle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setPath(v)));
            zip(filter.has('options'), rectangle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('bounds'), rectangle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setBounds(v)));
            zip(filter.has('extData'), rectangle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), rectangle).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
        filter.has('editor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.toggleEditor(v)));
    }
    /**
     * 获取已创建的 AMap.Rectangle 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapRectangleDirective.ɵfac = function AmapRectangleDirective_Factory(t) { return new (t || AmapRectangleDirective)(ɵngcc0.ɵɵdirectiveInject(AmapRectangleService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapRectangleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapRectangleDirective, selectors: [["amap-rectangle"]], inputs: { bounds: "bounds", options: "options" }, exportAs: ["rectangle"], features: [ɵngcc0.ɵɵProvidersFeature([AmapRectangleService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapRectangleDirective.ctorParameters = () => [
    { type: AmapRectangleService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
AmapRectangleDirective.propDecorators = {
    bounds: [{ type: Input }],
    options: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapRectangleDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-rectangle',
                exportAs: 'rectangle',
                providers: [AmapRectangleService]
            }]
    }], function () { return [{ type: AmapRectangleService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { bounds: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 矩形的范围
     * @type {?}
     */
    AmapRectangleDirective.prototype.bounds;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AmapRectangleDirective.prototype.options;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapRectangleDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapRectangleDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapRectangleDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: base/amap-circle.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CircleOptions = [
    'zIndex',
    'center',
    'bubble',
    'cursor',
    'radius',
    'strokeColor',
    'strokeOpacity',
    'strokeWeight',
    'fillColor',
    'fillOpacity',
    'strokeStyle',
    'extData',
    'strokeDasharray',
];
/**
 * @template T
 */
class AMapCircle extends AMapShapeOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     */
    constructor(os, binder) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否开启编辑器
         */
        this.editor = false;
        // directive events:
        this.naReady = new EventEmitter();
    }
}
AMapCircle.ɵfac = function AMapCircle_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AMapCircle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AMapCircle, inputs: { hidden: "hidden", editor: "editor", zIndex: "zIndex", center: "center", radius: "radius", strokeColor: "strokeColor", strokeOpacity: "strokeOpacity", strokeWeight: "strokeWeight", fillColor: "fillColor", fillOpacity: "fillOpacity", strokeStyle: "strokeStyle", strokeDasharray: "strokeDasharray", options: "options" }, outputs: { naReady: "naReady" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
AMapCircle.propDecorators = {
    zIndex: [{ type: Input }],
    center: [{ type: Input }],
    radius: [{ type: Input }],
    strokeColor: [{ type: Input }],
    strokeOpacity: [{ type: Input }],
    strokeWeight: [{ type: Input }],
    fillColor: [{ type: Input }],
    fillOpacity: [{ type: Input }],
    strokeStyle: [{ type: Input }],
    strokeDasharray: [{ type: Input }],
    hidden: [{ type: Input }],
    editor: [{ type: Input }],
    options: [{ type: Input }],
    naReady: [{ type: Output }]
};

if (false) {
    /**
     * 层叠顺序，默认zIndex:10
     * @type {?}
     */
    AMapCircle.prototype.zIndex;
    /**
     * 圆心位置
     * @type {?}
     */
    AMapCircle.prototype.center;
    /**
     * 圆半径，单位:米
     * @type {?}
     */
    AMapCircle.prototype.radius;
    /**
     * 线条颜色，使用16进制颜色代码赋值。默认值为#006600
     * @type {?}
     */
    AMapCircle.prototype.strokeColor;
    /**
     * 轮廓线透明度，取值范围[0,1]，0表示完全透明，1表示不透明。默认为0.9
     * @type {?}
     */
    AMapCircle.prototype.strokeOpacity;
    /**
     * 轮廓线宽度
     * @type {?}
     */
    AMapCircle.prototype.strokeWeight;
    /**
     * 圆形填充颜色,使用16进制颜色代码赋值。默认值为#006600
     * @type {?}
     */
    AMapCircle.prototype.fillColor;
    /**
     * 圆形填充透明度，取值范围[0,1]，0表示完全透明，1表示不透明。默认为0.9
     * @type {?}
     */
    AMapCircle.prototype.fillOpacity;
    /**
     * 轮廓线样式，实线:solid，虚线:dashed
     * @type {?}
     */
    AMapCircle.prototype.strokeStyle;
    /**
     * 勾勒形状轮廓的虚线和间隙的样式
     * @type {?}
     */
    AMapCircle.prototype.strokeDasharray;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AMapCircle.prototype.hidden;
    /**
     * 额外: 是否开启编辑器
     * @type {?}
     */
    AMapCircle.prototype.editor;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AMapCircle.prototype.options;
    /** @type {?} */
    AMapCircle.prototype.naReady;
    /**
     * @type {?}
     * @protected
     */
    AMapCircle.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AMapCircle.prototype.binder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-circle/amap-circle.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$j = 'AmapCircle';
class AmapCircleService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     * @param {?} plugins
     */
    constructor(amaps, logger, ngZone, plugins) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.plugins = plugins;
        this.circle$ = new ReplaySubject(1);
        this.editor$ = new ReplaySubject(1);
    }
    /**
     * 获取圆形
     * @return {?}
     */
    get() {
        return this.circle$.asObservable();
    }
    /**
     * 创建圆形 AMap.Circle
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.circle = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Circle(options)));
            this.logger.d(TAG$j, 'new Circle created.');
            this.circle$.next(this.circle);
            this.circle$.complete();
            return this.circle;
        })));
    }
    /**
     * 销毁圆形
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$j, 'Circle destroyed.');
            this.circle = null;
        }));
    }
    /**
     * @return {?}
     */
    getEditor() {
        // plugin is loading:
        return this.editor$.asObservable();
    }
    /**
     * 加载编辑插件
     * @return {?}
     */
    loadEditor() {
        return this.plugins.load('AMap.CircleEditor');
    }
    /**
     * 创建编辑器
     * @return {?}
     */
    createEditor() {
        return this.loadEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.editor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.CircleEditor(m, p)));
            this.logger.d(TAG$j, 'new CircleEditor created.');
            this.editor$.next(this.editor);
            this.editor$.complete();
            return this.editor;
        })));
    }
    /**
     * 开关编辑器
     * @param {?} v 开关选项
     * @return {?}
     */
    toggleEditor(v) {
        if (v && !this.editor) {
            this.createEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.editor) {
            if (v) {
                this.editor.open();
            }
            else {
                this.editor.close();
            }
        }
    }
}
AmapCircleService.ɵfac = function AmapCircleService_Factory(t) { return new (t || AmapCircleService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PluginLoaderService)); };
AmapCircleService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapCircleService, factory: AmapCircleService.ɵfac });
/** @nocollapse */
AmapCircleService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone },
    { type: PluginLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapCircleService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }, { type: PluginLoaderService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.circle;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.circle$;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.editor;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.editor$;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AmapCircleService.prototype.plugins;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-circle/amap-circle.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$k = 'amap-circle';
class AmapCircleDirective extends AMapCircle {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        this.inited = false;
        /** @type {?} */
        const editor = this.os.getEditor();
        this.naEditorAddNode = this.binder.bindEvent(editor, 'addnode');
        this.naEditorRemoveNode = this.binder.bindEvent(editor, 'removenode');
        this.naEditorAdjust = this.binder.bindEvent(editor, 'adjust');
        this.naEditorEnd = this.binder.bindEvent(editor, 'end');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const circle = this.get();
        if (!this.inited) {
            this.logger.d(TAG$k, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, CircleOptions);
            this.logger.d(TAG$k, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$k, 'circle is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('center'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setCenter(v)));
            zip(filter.has('options'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('radius'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setRadius(v)));
            zip(filter.has('extData'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), circle).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
        filter.has('editor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.toggleEditor(v)));
    }
    /**
     * 获取已创建的 AMap.Circle 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapCircleDirective.ɵfac = function AmapCircleDirective_Factory(t) { return new (t || AmapCircleDirective)(ɵngcc0.ɵɵdirectiveInject(AmapCircleService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapCircleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapCircleDirective, selectors: [["amap-circle"]], outputs: { naEditorAddNode: "naEditorAddNode", naEditorRemoveNode: "naEditorRemoveNode", naEditorAdjust: "naEditorAdjust", naEditorEnd: "naEditorEnd" }, exportAs: ["circle"], features: [ɵngcc0.ɵɵProvidersFeature([AmapCircleService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapCircleDirective.ctorParameters = () => [
    { type: AmapCircleService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
AmapCircleDirective.propDecorators = {
    naEditorAddNode: [{ type: Output }],
    naEditorRemoveNode: [{ type: Output }],
    naEditorAdjust: [{ type: Output }],
    naEditorEnd: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapCircleDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-circle',
                exportAs: 'circle',
                providers: [AmapCircleService]
            }]
    }], function () { return [{ type: AmapCircleService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { naEditorAddNode: [{
            type: Output
        }], naEditorRemoveNode: [{
            type: Output
        }], naEditorAdjust: [{
            type: Output
        }], naEditorEnd: [{
            type: Output
        }] }); })();
if (false) {
    /** @type {?} */
    AmapCircleDirective.prototype.naEditorAddNode;
    /** @type {?} */
    AmapCircleDirective.prototype.naEditorRemoveNode;
    /** @type {?} */
    AmapCircleDirective.prototype.naEditorAdjust;
    /** @type {?} */
    AmapCircleDirective.prototype.naEditorEnd;
    /**
     * @type {?}
     * @private
     */
    AmapCircleDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapCircleDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapCircleDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapCircleDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapCircleDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-circle-marker/amap-circle-marker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$l = 'AmapCircleMarker';
class AmapCircleMarkerService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, logger, ngZone) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.circle$ = new ReplaySubject(1);
    }
    /**
     * 获取圆点标记
     * @return {?}
     */
    get() {
        return this.circle$.asObservable();
    }
    /**
     * 创建圆点标记 AMap.CircleMarker
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.circle = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.CircleMarker(options)));
            this.logger.d(TAG$l, 'new CircleMarker created.');
            this.circle$.next(this.circle);
            this.circle$.complete();
            return this.circle;
        })));
    }
    /**
     * 销毁圆点标记
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$l, 'CircleMarker destroyed.');
            this.circle = null;
        }));
    }
}
AmapCircleMarkerService.ɵfac = function AmapCircleMarkerService_Factory(t) { return new (t || AmapCircleMarkerService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapCircleMarkerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapCircleMarkerService, factory: AmapCircleMarkerService.ɵfac });
/** @nocollapse */
AmapCircleMarkerService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapCircleMarkerService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerService.prototype.circle;
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerService.prototype.circle$;
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-circle-marker/amap-circle-marker.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$m = 'amap-circle-marker';
class AmapCircleMarkerDirective extends AMapCircle {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        this.inited = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const circle = this.get();
        if (!this.inited) {
            this.logger.d(TAG$m, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, CircleOptions);
            this.logger.d(TAG$m, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$m, 'circle marker is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('center'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setCenter(v)));
            zip(filter.has('options'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('radius'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setRadius(v)));
            zip(filter.has('extData'), circle).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), circle).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
    }
    /**
     * 获取已创建的 AMap.CircleMarker 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapCircleMarkerDirective.ɵfac = function AmapCircleMarkerDirective_Factory(t) { return new (t || AmapCircleMarkerDirective)(ɵngcc0.ɵɵdirectiveInject(AmapCircleMarkerService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapCircleMarkerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapCircleMarkerDirective, selectors: [["amap-circle-marker"]], exportAs: ["circle-marker"], features: [ɵngcc0.ɵɵProvidersFeature([AmapCircleMarkerService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapCircleMarkerDirective.ctorParameters = () => [
    { type: AmapCircleMarkerService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapCircleMarkerDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-circle-marker',
                exportAs: 'circle-marker',
                providers: [AmapCircleMarkerService]
            }]
    }], function () { return [{ type: AmapCircleMarkerService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapCircleMarkerDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapCircleMarkerDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapCircleMarkerDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-ellipse/amap-ellipse.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$n = 'AmapEllipse';
class AmapEllipseService {
    /**
     * @param {?} amaps
     * @param {?} logger
     * @param {?} ngZone
     * @param {?} plugins
     */
    constructor(amaps, logger, ngZone, plugins) {
        this.amaps = amaps;
        this.logger = logger;
        this.ngZone = ngZone;
        this.plugins = plugins;
        this.ellipse$ = new ReplaySubject(1);
        this.editor$ = new ReplaySubject(1);
    }
    /**
     * 获取椭圆
     * @return {?}
     */
    get() {
        return this.ellipse$.asObservable();
    }
    /**
     * 创建椭圆 AMap.Ellipse
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return this.amaps.get().pipe(map((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            options.map = m;
            this.ellipse = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Ellipse(options)));
            this.logger.d(TAG$n, 'new Ellipse created.');
            this.ellipse$.next(this.ellipse);
            this.ellipse$.complete();
            return this.ellipse;
        })));
    }
    /**
     * 销毁椭圆
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$n, 'Ellipse destroyed.');
            this.ellipse = null;
        }));
    }
    /**
     * @return {?}
     */
    getEditor() {
        // plugin is loading:
        return this.editor$.asObservable();
    }
    /**
     * 加载编辑插件
     * @return {?}
     */
    loadEditor() {
        return this.plugins.load('AMap.EllipseEditor');
    }
    /**
     * 创建编辑器
     * @return {?}
     */
    createEditor() {
        return this.loadEditor().pipe(switchMapTo(zip(this.amaps.get(), this.get())), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, p]) => {
            this.editor = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.EllipseEditor(m, p)));
            this.logger.d(TAG$n, 'new EllipseEditor created.');
            this.editor$.next(this.editor);
            this.editor$.complete();
            return this.editor;
        })));
    }
    /**
     * 开关编辑器
     * @param {?} v 开关选项
     * @return {?}
     */
    toggleEditor(v) {
        if (v && !this.editor) {
            this.createEditor().subscribe((/**
             * @param {?} editor
             * @return {?}
             */
            editor => editor.open()));
            return;
        }
        if (this.editor) {
            if (v) {
                this.editor.open();
            }
            else {
                this.editor.close();
            }
        }
    }
}
AmapEllipseService.ɵfac = function AmapEllipseService_Factory(t) { return new (t || AmapEllipseService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PluginLoaderService)); };
AmapEllipseService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapEllipseService, factory: AmapEllipseService.ɵfac });
/** @nocollapse */
AmapEllipseService.ctorParameters = () => [
    { type: AMapService },
    { type: LoggerService },
    { type: NgZone },
    { type: PluginLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapEllipseService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }, { type: PluginLoaderService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.ellipse;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.ellipse$;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.editor;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.editor$;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseService.prototype.plugins;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-ellipse/amap-ellipse.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$o = 'amap-ellipse';
/** @type {?} */
const EllipseOptions = [...PolygonOptions, 'center', 'radius'];
class AmapEllipseDirective extends AMapPolygon {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        this.inited = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const ellipse = this.get();
        if (!this.inited) {
            this.logger.d(TAG$o, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, EllipseOptions);
            this.logger.d(TAG$o, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$o, 'ellipse is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('center'), ellipse).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setCenter(v)));
            zip(filter.has('options'), ellipse).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
            zip(filter.has('extData'), ellipse).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setExtData(v)));
        }
        zip(filter.has('hidden'), ellipse).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
        filter.has('editor').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.os.toggleEditor(v)));
    }
    /**
     * 获取已创建的 AMap.Ellipse 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapEllipseDirective.ɵfac = function AmapEllipseDirective_Factory(t) { return new (t || AmapEllipseDirective)(ɵngcc0.ɵɵdirectiveInject(AmapEllipseService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapEllipseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapEllipseDirective, selectors: [["amap-ellipse"]], inputs: { center: "center", radius: "radius", options: "options" }, exportAs: ["ellipse"], features: [ɵngcc0.ɵɵProvidersFeature([AmapEllipseService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapEllipseDirective.ctorParameters = () => [
    { type: AmapEllipseService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
AmapEllipseDirective.propDecorators = {
    center: [{ type: Input }],
    radius: [{ type: Input }],
    options: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapEllipseDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-ellipse',
                exportAs: 'ellipse',
                providers: [AmapEllipseService]
            }]
    }], function () { return [{ type: AmapEllipseService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { center: [{
            type: Input
        }], radius: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 椭圆的中心
     * @type {?}
     */
    AmapEllipseDirective.prototype.center;
    /**
     * 椭圆半径
     * @type {?}
     */
    AmapEllipseDirective.prototype.radius;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AmapEllipseDirective.prototype.options;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapEllipseDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapEllipseDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapEllipseDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-tool-bar/amap-tool-bar.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$p = 'AmapToolBar';
var AMapToolBar;
(function (AMapToolBar) {
    /**
     * @record
     */
    function Options() { }
    AMapToolBar.Options = Options;
    if (false) {
        /**
         * 相对于地图容器左上角的偏移量
         * @type {?|undefined}
         */
        Options.prototype.offset;
        /**
         * 控件停靠位置
         * LT:左上角;
         * RT:右上角;
         * LB:左下角;
         * RB:右下角;
         * @type {?|undefined}
         */
        Options.prototype.position;
        /**
         * 标尺键盘是否可见
         * @type {?|undefined}
         */
        Options.prototype.ruler;
        /**
         * 定位失败后，是否开启IP定位
         * @type {?|undefined}
         */
        Options.prototype.noIpLocate;
        /**
         * 是否显示定位按钮
         * @type {?|undefined}
         */
        Options.prototype.locate;
        /**
         * 是否使用精简模式
         * @type {?|undefined}
         */
        Options.prototype.liteStyle;
        /**
         * 方向键盘是否可见
         * @type {?|undefined}
         */
        Options.prototype.direction;
        /**
         * 是否自动定位，即地图初始化加载完成后，是否自动定位的用户所在地，仅在支持HTML5的浏览器中有效
         * @type {?|undefined}
         */
        Options.prototype.autoPosition;
        /**
         * 自定义定位图标，值为Marker对象
         * @type {?|undefined}
         */
        Options.prototype.locationMarker;
        /**
         * 是否使用高德定位sdk用来辅助优化定位效果
         * @type {?|undefined}
         */
        Options.prototype.useNative;
        /** @type {?|undefined} */
        Options.prototype.timeout;
    }
})(AMapToolBar || (AMapToolBar = {}));
class AmapToolBarService {
    /**
     * @param {?} amaps
     * @param {?} plugin
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, plugin, logger, ngZone) {
        this.amaps = amaps;
        this.plugin = plugin;
        this.logger = logger;
        this.ngZone = ngZone;
        this.toolBar$ = new ReplaySubject(1);
    }
    /**
     * 获取工具条
     * @return {?}
     */
    get() {
        return this.toolBar$.asObservable();
    }
    /**
     * 创建工具条 AMap.ToolBar
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return zip(this.amaps.get(), this.plugin.load('AMap.ToolBar')).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m]) => {
            this.toolBar = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.ToolBar(options)));
            this.logger.d(TAG$p, 'new toolBar created.');
            m.addControl(this.toolBar);
            this.toolBar$.next(this.toolBar);
            this.toolBar$.complete();
            return this.toolBar;
        })));
    }
    /**
     * 销毁工具条
     * @return {?}
     */
    destroy() {
        zip(this.amaps.get(), this.get()).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([m, toolBar]) => {
            m.removeControl(toolBar);
            this.logger.d(TAG$p, 'toolBar destroyed.');
            this.toolBar = null;
        }));
    }
}
AmapToolBarService.ɵfac = function AmapToolBarService_Factory(t) { return new (t || AmapToolBarService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(PluginLoaderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapToolBarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapToolBarService, factory: AmapToolBarService.ɵfac });
/** @nocollapse */
AmapToolBarService.ctorParameters = () => [
    { type: AMapService },
    { type: PluginLoaderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapToolBarService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: PluginLoaderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapToolBarService.prototype.toolBar;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarService.prototype.toolBar$;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarService.prototype.plugin;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-tool-bar/amap-tool-bar.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$q = 'amap-tool-bar';
/** @type {?} */
const ToolBarOptions = [
    'offset',
    'position',
    'ruler',
    'noIpLocate',
    'locate',
    'liteStyle',
    'direction',
    'autoPosition',
    'locationMarker',
    'useNative',
];
class AmapToolBarDirective {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} pixels
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, pixels, logger, ngZone) {
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.pixels = pixels;
        this.logger = logger;
        this.ngZone = ngZone;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        // amap-tool-bar events:
        this.naReady = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        const target = this.os.get();
        this.naShow = this.binder.bindEvent(target, 'show');
        this.naHide = this.binder.bindEvent(target, 'hide');
        this.naLocation = this.binder.bindEvent(target, 'location');
        this.naZoomChanged = this.binder.bindEvent(target, 'zoomchanged');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.amaps.get().subscribe((/**
         * @return {?}
         */
        () => {
            this.logger.d(TAG$q, 'initializing ...');
            /** @type {?} */
            const options = getOptions(this, ToolBarOptions);
            if (this.offset) {
                options.offset = this.pixels.create(this.offset);
            }
            this.logger.d(TAG$q, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$q, 'toolbar is ready.');
            }));
            this.inited = true;
            this.get().subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.hidden ? m.hide() : m.show();
            }));
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const toolbar = this.get();
        if (!this.inited) {
            return;
        }
        zip(filter.notEmpty('offset'), toolbar).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => m.setOffset(this.pixels.create(v))));
        zip(filter.has('hidden'), toolbar).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => (v ? m.hide() : m.show())));
    }
    /**
     * 获取已创建的 AMap.ToolBar 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
    /**
     * @return {?}
     */
    doLocation() {
        this.os.get().subscribe((/**
         * @param {?} toolbar
         * @return {?}
         */
        toolbar => {
            toolbar.doLocation();
        }));
    }
}
AmapToolBarDirective.ɵfac = function AmapToolBarDirective_Factory(t) { return new (t || AmapToolBarDirective)(ɵngcc0.ɵɵdirectiveInject(AmapToolBarService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapToolBarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapToolBarDirective, selectors: [["amap-tool-bar"]], inputs: { hidden: "hidden", offset: "offset", position: "position", ruler: "ruler", noIpLocate: "noIpLocate", locate: "locate", liteStyle: "liteStyle", direction: "direction", autoPosition: "autoPosition", locationMarker: "locationMarker", useNative: "useNative" }, outputs: { naReady: "naReady", naShow: "naShow", naHide: "naHide", naLocation: "naLocation", naZoomChanged: "naZoomChanged" }, exportAs: ["tool-bar"], features: [ɵngcc0.ɵɵProvidersFeature([AmapToolBarService]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapToolBarDirective.ctorParameters = () => [
    { type: AmapToolBarService },
    { type: EventBinderService },
    { type: AMapService },
    { type: PixelService },
    { type: LoggerService },
    { type: NgZone }
];
AmapToolBarDirective.propDecorators = {
    offset: [{ type: Input }],
    position: [{ type: Input }],
    ruler: [{ type: Input }],
    noIpLocate: [{ type: Input }],
    locate: [{ type: Input }],
    liteStyle: [{ type: Input }],
    direction: [{ type: Input }],
    autoPosition: [{ type: Input }],
    locationMarker: [{ type: Input }],
    useNative: [{ type: Input }],
    hidden: [{ type: Input }],
    naReady: [{ type: Output }],
    naShow: [{ type: Output }],
    naHide: [{ type: Output }],
    naLocation: [{ type: Output }],
    naZoomChanged: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapToolBarDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-tool-bar',
                exportAs: 'tool-bar',
                providers: [AmapToolBarService]
            }]
    }], function () { return [{ type: AmapToolBarService }, { type: EventBinderService }, { type: AMapService }, { type: PixelService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { hidden: [{
            type: Input
        }], naReady: [{
            type: Output
        }], naShow: [{
            type: Output
        }], naHide: [{
            type: Output
        }], naLocation: [{
            type: Output
        }], naZoomChanged: [{
            type: Output
        }], offset: [{
            type: Input
        }], position: [{
            type: Input
        }], ruler: [{
            type: Input
        }], noIpLocate: [{
            type: Input
        }], locate: [{
            type: Input
        }], liteStyle: [{
            type: Input
        }], direction: [{
            type: Input
        }], autoPosition: [{
            type: Input
        }], locationMarker: [{
            type: Input
        }], useNative: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 相对于地图容器左上角的偏移量
     * @type {?}
     */
    AmapToolBarDirective.prototype.offset;
    /**
     * 控件停靠位置
     * LT: 左上角
     * RT: 右上角
     * LB: 左下角
     * RB: 右下角
     * @type {?}
     */
    AmapToolBarDirective.prototype.position;
    /**
     * 标尺键盘是否可见
     * @type {?}
     */
    AmapToolBarDirective.prototype.ruler;
    /**
     * 定位失败后，是否开启 IP 定位
     * @type {?}
     */
    AmapToolBarDirective.prototype.noIpLocate;
    /**
     * 是否显示定位按钮
     * @type {?}
     */
    AmapToolBarDirective.prototype.locate;
    /**
     * 是否使用精简模式
     * @type {?}
     */
    AmapToolBarDirective.prototype.liteStyle;
    /**
     * 方向键盘是否可见
     * @type {?}
     */
    AmapToolBarDirective.prototype.direction;
    /**
     * 是否自动定位，即地图初始化加载完成后，是否自动定位的用户所在地，仅在支持 HTML5 的浏览器中有效
     * @type {?}
     */
    AmapToolBarDirective.prototype.autoPosition;
    /**
     * 自定义定位图标，值为 Marker 对象
     * @type {?}
     */
    AmapToolBarDirective.prototype.locationMarker;
    /**
     * 是否使用高德定位 SDK 用来辅助优化定位效果
     * @type {?}
     */
    AmapToolBarDirective.prototype.useNative;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AmapToolBarDirective.prototype.hidden;
    /** @type {?} */
    AmapToolBarDirective.prototype.naReady;
    /** @type {?} */
    AmapToolBarDirective.prototype.naShow;
    /** @type {?} */
    AmapToolBarDirective.prototype.naHide;
    /** @type {?} */
    AmapToolBarDirective.prototype.naLocation;
    /** @type {?} */
    AmapToolBarDirective.prototype.naZoomChanged;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapToolBarDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapToolBarDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarDirective.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarDirective.prototype.pixels;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapToolBarDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-marker-clusterer/amap-marker-clusterer.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AMapMarkerClusterer;
(function (AMapMarkerClusterer) {
    /**
     * @record
     */
    function StyleObject() { }
    AMapMarkerClusterer.StyleObject = StyleObject;
    if (false) {
        /** @type {?|undefined} */
        StyleObject.prototype.url;
        /** @type {?|undefined} */
        StyleObject.prototype.size;
        /** @type {?|undefined} */
        StyleObject.prototype.offset;
        /** @type {?|undefined} */
        StyleObject.prototype.imageOffset;
        /** @type {?|undefined} */
        StyleObject.prototype.textColor;
        /** @type {?|undefined} */
        StyleObject.prototype.textSize;
    }
    /**
     * @record
     */
    function Options() { }
    AMapMarkerClusterer.Options = Options;
    if (false) {
        /**
         * 聚合计算时网格的像素大小，默认60
         * @type {?|undefined}
         */
        Options.prototype.gridSize;
        /**
         * 聚合的最小数量。默认值为2，即小于2个点则不能成为一个聚合
         * @type {?|undefined}
         */
        Options.prototype.minClusterSize;
        /**
         * 最大的聚合级别，大于该级别就不进行相应的聚合。默认值为18
         * @type {?|undefined}
         */
        Options.prototype.maxZoom;
        /**
         * 聚合点的图标位置是否是所有聚合内点的中心点。默认为否
         * @type {?|undefined}
         */
        Options.prototype.averageCenter;
        /**
         * 指定聚合后的点标记的图标样式，可缺省，缺省时为默认样式
         * @type {?|undefined}
         */
        Options.prototype.styles;
        /**
         * 该方法用来实现聚合点的自定义绘制
         * @type {?|undefined}
         */
        Options.prototype.renderClusterMarker;
        /**
         * 点击聚合点时，是否散开，默认值为：true
         * @type {?|undefined}
         */
        Options.prototype.zoomOnClick;
    }
})(AMapMarkerClusterer || (AMapMarkerClusterer = {}));
/** @type {?} */
const TAG$r = 'AmapMarkerCluster';
class AmapMarkerClustererService {
    /**
     * @param {?} amaps
     * @param {?} plugins
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, plugins, logger, ngZone) {
        this.amaps = amaps;
        this.plugins = plugins;
        this.logger = logger;
        this.ngZone = ngZone;
        this.markerClusterer$ = new ReplaySubject(1);
    }
    /**
     * 获取点聚合
     * @return {?}
     */
    get() {
        return this.markerClusterer$.asObservable();
    }
    /**
     * 创建点聚合 AMap.MarkerClusterer
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return zip(this.amaps.get(), this.plugins.load('AMap.MarkerClusterer')).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m]) => {
            this.markerClusterer = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.MarkerClusterer(m, [], options)));
            this.logger.d(TAG$r, 'new markerClusterer created.');
            this.markerClusterer$.next(this.markerClusterer);
            this.markerClusterer$.complete();
            return this.markerClusterer;
        })));
    }
    /**
     * 销毁点聚合
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.clearMarkers();
            m.setMap(null);
            this.logger.d(TAG$r, 'markerClusterer destroyed.');
            this.markerClusterer = null;
        }));
    }
}
AmapMarkerClustererService.ɵfac = function AmapMarkerClustererService_Factory(t) { return new (t || AmapMarkerClustererService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(PluginLoaderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapMarkerClustererService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapMarkerClustererService, factory: AmapMarkerClustererService.ɵfac });
/** @nocollapse */
AmapMarkerClustererService.ctorParameters = () => [
    { type: AMapService },
    { type: PluginLoaderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapMarkerClustererService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: PluginLoaderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererService.prototype.markerClusterer;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererService.prototype.markerClusterer$;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererService.prototype.plugins;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-marker-clusterer/amap-marker-clusterer.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$s = 'amap-marker-clusterer';
/** @type {?} */
const MarkerClusterOptions = [
    'gridSize',
    'minClusterSize',
    'maxZoom',
    'averageCenter',
    'styles',
    'renderClusterMarker',
    'zoomOnClick',
];
class AmapMarkerClustererDirective {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} pixels
     * @param {?} sizes
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, pixels, sizes, logger, ngZone) {
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.pixels = pixels;
        this.sizes = sizes;
        this.logger = logger;
        this.ngZone = ngZone;
        // ---- Events ----
        this.naReady = new EventEmitter();
        // amap-marker directives:
        this.markerList = new QueryList();
        this.inited = false;
        /** @type {?} */
        const target = this.os.get();
        this.naClick = this.binder.bindEvent(target, 'click');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.amaps.get().subscribe((/**
         * @return {?}
         */
        () => {
            this.logger.d(TAG$s, 'initializing ...');
            /** @type {?} */
            const options = getOptions(this, MarkerClusterOptions);
            if (options.styles) {
                options.styles = options.styles.map((/**
                 * @param {?} style
                 * @return {?}
                 */
                style => {
                    if (style.size) {
                        style.size = (/** @type {?} */ (this.sizes.create(style.size)));
                    }
                    if (style.offset) {
                        style.offset = this.pixels.create(style.offset);
                    }
                    if (style.imageOffset) {
                        style.imageOffset = this.pixels.create(style.imageOffset);
                    }
                    return style;
                }));
            }
            this.logger.d(TAG$s, 'options:', options);
            this.os.create(options).subscribe();
            this.inited = true;
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.inited) {
            return;
        }
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const cluster = this.get();
        zip(filter.notEmpty('gridSize'), cluster).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, c]) => c.setGridSize(v)));
        zip(filter.notEmpty('minClusterSize'), cluster).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, c]) => c.setMinClusterSize(v)));
        zip(filter.has('maxZoom'), cluster).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, c]) => c.setMaxZoom(v)));
        zip(filter.has('averageCenter'), cluster).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, c]) => c.setAverageCenter(v)));
        zip(filter.has('styles'), cluster).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, c]) => c.setStyles(v)));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateMarkers().subscribe((/**
         * @param {?} c
         * @return {?}
         */
        c => {
            this.ngZone.run((/**
             * @return {?}
             */
            () => this.naReady.emit(c)));
            this.logger.d(TAG$s, 'markerClusterer is ready.');
        }));
        this.markerList.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateMarkers().subscribe()));
    }
    /**
     * @private
     * @return {?}
     */
    updateMarkers() {
        return zip(combineLatest(this.markerList.map((/**
         * @param {?} d
         * @return {?}
         */
        d => d.get()))), this.get()).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([markers, cluster]) => {
            cluster.setMarkers(markers);
            return cluster;
        })));
    }
    /**
     * 获取已创建的 AMap.MarkerClusterer 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapMarkerClustererDirective.ɵfac = function AmapMarkerClustererDirective_Factory(t) { return new (t || AmapMarkerClustererDirective)(ɵngcc0.ɵɵdirectiveInject(AmapMarkerClustererService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(SizeService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapMarkerClustererDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapMarkerClustererDirective, selectors: [["amap-marker-clusterer"]], contentQueries: function AmapMarkerClustererDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AmapMarkerDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.markerList = _t);
    } }, inputs: { gridSize: "gridSize", minClusterSize: "minClusterSize", maxZoom: "maxZoom", averageCenter: "averageCenter", styles: "styles", renderClusterMarker: "renderClusterMarker", zoomOnClick: "zoomOnClick" }, outputs: { naReady: "naReady", naClick: "naClick" }, exportAs: ["marker-clusterer"], features: [ɵngcc0.ɵɵProvidersFeature([AmapMarkerClustererService]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapMarkerClustererDirective.ctorParameters = () => [
    { type: AmapMarkerClustererService },
    { type: EventBinderService },
    { type: AMapService },
    { type: PixelService },
    { type: SizeService },
    { type: LoggerService },
    { type: NgZone }
];
AmapMarkerClustererDirective.propDecorators = {
    gridSize: [{ type: Input }],
    minClusterSize: [{ type: Input }],
    maxZoom: [{ type: Input }],
    averageCenter: [{ type: Input }],
    styles: [{ type: Input }],
    renderClusterMarker: [{ type: Input }],
    zoomOnClick: [{ type: Input }],
    naReady: [{ type: Output }],
    naClick: [{ type: Output }],
    markerList: [{ type: ContentChildren, args: [AmapMarkerDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapMarkerClustererDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-marker-clusterer',
                exportAs: 'marker-clusterer',
                providers: [AmapMarkerClustererService]
            }]
    }], function () { return [{ type: AmapMarkerClustererService }, { type: EventBinderService }, { type: AMapService }, { type: PixelService }, { type: SizeService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { naReady: [{
            type: Output
        }], markerList: [{
            type: ContentChildren,
            args: [AmapMarkerDirective]
        }], naClick: [{
            type: Output
        }], gridSize: [{
            type: Input
        }], minClusterSize: [{
            type: Input
        }], maxZoom: [{
            type: Input
        }], averageCenter: [{
            type: Input
        }], styles: [{
            type: Input
        }], renderClusterMarker: [{
            type: Input
        }], zoomOnClick: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 聚合计算时网格的像素大小，默认60
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.gridSize;
    /**
     * 聚合的最小数量。默认值为2，即小于2个点则不能成为一个聚合
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.minClusterSize;
    /**
     * 最大的聚合级别，大于该级别就不进行相应的聚合。默认值为18
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.maxZoom;
    /**
     * 聚合点的图标位置是否是所有聚合内点的中心点。默认为否
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.averageCenter;
    /**
     * 指定聚合后的点标记的图标样式，可缺省，缺省时为默认样式
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.styles;
    /**
     * 该方法用来实现聚合点的自定义绘制
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.renderClusterMarker;
    /**
     * 点击聚合点时，是否散开，默认值为：true
     * @type {?}
     */
    AmapMarkerClustererDirective.prototype.zoomOnClick;
    /** @type {?} */
    AmapMarkerClustererDirective.prototype.naReady;
    /** @type {?} */
    AmapMarkerClustererDirective.prototype.naClick;
    /** @type {?} */
    AmapMarkerClustererDirective.prototype.markerList;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapMarkerClustererDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    AmapMarkerClustererDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererDirective.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererDirective.prototype.pixels;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererDirective.prototype.sizes;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapMarkerClustererDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-heatmap/amap-heatmap.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$t = 'AmapHeatmap';
var AMapHeatmap;
(function (AMapHeatmap) {
    /**
     * @record
     */
    function Options() { }
    AMapHeatmap.Options = Options;
    if (false) {
        /**
         * 热力图中单个点的半径，默认：30，单位：pixel
         * @type {?|undefined}
         */
        Options.prototype.radius;
        /**
         * 热力图的渐变区间
         * @type {?|undefined}
         */
        Options.prototype.gradient;
        /**
         * 热力图透明度数组，取值范围[0,1]，0表示完全透明，1表示不透明
         * 默认：[0,1]
         * @type {?|undefined}
         */
        Options.prototype.opacity;
        /**
         * 支持的缩放级别范围，取值范围[3-18]
         * 默认：[3,18]
         * @type {?|undefined}
         */
        Options.prototype.zooms;
        /** @type {?|undefined} */
        Options.prototype.rejectMapMask;
        /** @type {?|undefined} */
        Options.prototype.visible;
        /** @type {?|undefined} */
        Options.prototype.radiusUnit;
        /** @type {?|undefined} */
        Options.prototype.blur;
        /** @type {?|undefined} */
        Options.prototype.zIndex;
        /** @type {?|undefined} */
        Options.prototype.renderOnZooming;
        /* Skipping unnamed member:
        ['3d']?: {
              heightScale?: number;
              heightBezier?: number[];
              gridSize?: number;
              drawGridLine?: boolean;
            };*/
    }
    /**
     * @record
     */
    function Data() { }
    AMapHeatmap.Data = Data;
    if (false) {
        /**
         * 经度
         * @type {?}
         */
        Data.prototype.lng;
        /**
         * 维度
         * @type {?}
         */
        Data.prototype.lat;
        /**
         * 权重
         * @type {?}
         */
        Data.prototype.count;
    }
    /**
     * @record
     */
    function DataSet() { }
    AMapHeatmap.DataSet = DataSet;
    if (false) {
        /**
         * 权重的最大值
         * @type {?|undefined}
         */
        DataSet.prototype.max;
        /**
         * 坐标数据集
         * @type {?}
         */
        DataSet.prototype.data;
    }
})(AMapHeatmap || (AMapHeatmap = {}));
class AmapHeatmapService {
    /**
     * @param {?} amaps
     * @param {?} plugin
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, plugin, logger, ngZone) {
        this.amaps = amaps;
        this.plugin = plugin;
        this.logger = logger;
        this.ngZone = ngZone;
        this.heatmap$ = new ReplaySubject(1);
    }
    /**
     * 获取热力图
     * @return {?}
     */
    get() {
        return this.heatmap$.asObservable();
    }
    /**
     * 创建热力图 AMap.Heatmap
     * @param {?} options 选项
     * @return {?}
     */
    create(options) {
        return zip(this.amaps.get(), this.plugin.load('AMap.Heatmap')).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([m]) => {
            this.heatmap = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Heatmap(m, options)));
            this.logger.d(TAG$t, 'new Heatmap created.');
            this.heatmap$.next(this.heatmap);
            this.heatmap$.complete();
            return this.heatmap;
        })));
    }
    /**
     * 销毁热力图
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} heatmap
         * @return {?}
         */
        heatmap => {
            heatmap.setMap(null);
            this.logger.d(TAG$t, 'Heatmap destroyed.');
            this.heatmap = null;
        }));
    }
}
AmapHeatmapService.ɵfac = function AmapHeatmapService_Factory(t) { return new (t || AmapHeatmapService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(PluginLoaderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapHeatmapService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapHeatmapService, factory: AmapHeatmapService.ɵfac });
/** @nocollapse */
AmapHeatmapService.ctorParameters = () => [
    { type: AMapService },
    { type: PluginLoaderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapHeatmapService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: PluginLoaderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapService.prototype.heatmap;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapService.prototype.heatmap$;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapService.prototype.plugin;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/amap-heatmap/amap-heatmap.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$u = 'amap-heatmap';
/** @type {?} */
const HeatmapOptions = ['radius', 'gradient', 'opacity', 'zooms'];
class AmapHeatmapDirective {
    /**
     * @param {?} os
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, logger, ngZone) {
        this.os = os;
        this.logger = logger;
        this.ngZone = ngZone;
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        // ---- Events ----
        this.naReady = new EventEmitter();
        this.inited = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const heatmap = this.get();
        if (!this.inited) {
            this.logger.d(TAG$u, 'initializing ...');
            /** @type {?} */
            const options = this.options || getOptions(this, HeatmapOptions);
            this.logger.d(TAG$u, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$u, 'heatmap is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('options'), heatmap).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setOptions(v || {})));
        }
        zip(filter.notEmpty('dataset'), heatmap).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => {
            p.setDataSet(v);
        }));
        zip(filter.has('hidden'), heatmap).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, p]) => (v ? p.hide() : p.show())));
    }
    /**
     * 获取已创建的 AMap.Heatmap 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
AmapHeatmapDirective.ɵfac = function AmapHeatmapDirective_Factory(t) { return new (t || AmapHeatmapDirective)(ɵngcc0.ɵɵdirectiveInject(AmapHeatmapService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AmapHeatmapDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AmapHeatmapDirective, selectors: [["amap-heatmap"]], inputs: { hidden: "hidden", radius: "radius", gradient: "gradient", opacity: "opacity", zooms: "zooms", options: "options", dataset: "dataset" }, outputs: { naReady: "naReady" }, exportAs: ["heatmap"], features: [ɵngcc0.ɵɵProvidersFeature([AmapHeatmapService]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
AmapHeatmapDirective.ctorParameters = () => [
    { type: AmapHeatmapService },
    { type: LoggerService },
    { type: NgZone }
];
AmapHeatmapDirective.propDecorators = {
    radius: [{ type: Input }],
    gradient: [{ type: Input }],
    opacity: [{ type: Input }],
    zooms: [{ type: Input }],
    hidden: [{ type: Input }],
    options: [{ type: Input }],
    dataset: [{ type: Input }],
    naReady: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapHeatmapDirective, [{
        type: Directive,
        args: [{
                selector: 'amap-heatmap',
                exportAs: 'heatmap',
                providers: [AmapHeatmapService]
            }]
    }], function () { return [{ type: AmapHeatmapService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { hidden: [{
            type: Input
        }], naReady: [{
            type: Output
        }], radius: [{
            type: Input
        }], gradient: [{
            type: Input
        }], opacity: [{
            type: Input
        }], zooms: [{
            type: Input
        }], options: [{
            type: Input
        }], dataset: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 热力图中单个点的半径，默认：30，单位：pixel
     * @type {?}
     */
    AmapHeatmapDirective.prototype.radius;
    /**
     * 热力图的渐变区间
     * @type {?}
     */
    AmapHeatmapDirective.prototype.gradient;
    /**
     * 热力图透明度数组，取值范围[0,1]，0表示完全透明，1表示不透明
     * 默认：[0,1]
     * @type {?}
     */
    AmapHeatmapDirective.prototype.opacity;
    /**
     * 支持的缩放级别范围，取值范围[3-18]
     * 默认：[3,18]
     * @type {?}
     */
    AmapHeatmapDirective.prototype.zooms;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    AmapHeatmapDirective.prototype.hidden;
    /**
     * 额外: 会覆盖其他属性的配置方式
     * @type {?}
     */
    AmapHeatmapDirective.prototype.options;
    /**
     * 额外: 坐标数据集
     * @type {?}
     */
    AmapHeatmapDirective.prototype.dataset;
    /** @type {?} */
    AmapHeatmapDirective.prototype.naReady;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    AmapHeatmapDirective.prototype.os;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapHeatmapDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/amap-plugin-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$v = 'PluginLoader';
class AmapPluginLoaderService {
    /**
     * @param {?} mapLoader
     * @param {?} logger
     */
    constructor(mapLoader, logger) {
        this.mapLoader = mapLoader;
        this.logger = logger;
        this.state = new Map();
    }
    /**
     * 加载一个或多个插件
     * @param {?} name
     * @return {?}
     */
    load(name) {
        /** @type {?} */
        let pKey = '';
        if (Array.isArray(name)) {
            pKey = name.join(',');
        }
        else {
            pKey = name;
        }
        if (this.state.has(pKey)) {
            return this.state.get(pKey).asObservable();
        }
        this.logger.d(TAG$v, 'loading plugin:', pKey, '...');
        return this.mapLoader.load().pipe(switchMap((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const loading$ = new ReplaySubject(1);
            AMap.plugin(name, (/**
             * @return {?}
             */
            () => {
                this.logger.d(TAG$v, 'loading plugin:', pKey, 'COMPLETE');
                loading$.next();
                loading$.complete();
            }));
            this.state.set(pKey, loading$);
            return loading$.asObservable();
        })));
    }
}
AmapPluginLoaderService.ɵfac = function AmapPluginLoaderService_Factory(t) { return new (t || AmapPluginLoaderService)(ɵngcc0.ɵɵinject(AMapLoaderService), ɵngcc0.ɵɵinject(LoggerService)); };
AmapPluginLoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapPluginLoaderService, factory: AmapPluginLoaderService.ɵfac });
/** @nocollapse */
AmapPluginLoaderService.ctorParameters = () => [
    { type: AMapLoaderService },
    { type: LoggerService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapPluginLoaderService, [{
        type: Injectable
    }], function () { return [{ type: AMapLoaderService }, { type: LoggerService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapPluginLoaderService.prototype.state;
    /**
     * @type {?}
     * @private
     */
    AmapPluginLoaderService.prototype.mapLoader;
    /**
     * @type {?}
     * @private
     */
    AmapPluginLoaderService.prototype.logger;
}

/**
 * @fileoverview added by tsickle
 * Generated from: services/amap-autocomplete/amap-autocomplete.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$w = 'AmapAutocomplete';
var AMapAutocomplete;
(function (AMapAutocomplete) {
    /**
     * @record
     */
    function Options() { }
    AMapAutocomplete.Options = Options;
    if (false) {
        /**
         * 输入提示时限定POI类型，多个类型用“|”分隔
         * @type {?|undefined}
         */
        Options.prototype.type;
        /**
         * 输入提示时限定城市
         * @type {?|undefined}
         */
        Options.prototype.city;
        /**
         * 返回的数据类型
         * @type {?|undefined}
         */
        Options.prototype.datatype;
        /**
         * 是否强制限制在设置的城市内搜索
         * @type {?|undefined}
         */
        Options.prototype.citylimit;
        /**
         * 指定输入框
         * @type {?|undefined}
         */
        Options.prototype.input;
        /**
         * 指定输出面板
         * @type {?|undefined}
         */
        Options.prototype.output;
        /**
         * 是否在input位于页面较下方的时候自动将输入面板显示在input上方以避免被遮挡
         * @type {?|undefined}
         */
        Options.prototype.outPutDirAuto;
    }
    /**
     * @record
     */
    function Tip() { }
    AMapAutocomplete.Tip = Tip;
    if (false) {
        /**
         * 名称
         * @type {?}
         */
        Tip.prototype.name;
        /**
         * 所属区域
         * @type {?}
         */
        Tip.prototype.district;
        /**
         * 区域编码
         * @type {?}
         */
        Tip.prototype.adcode;
        /**
         * 地址
         * @type {?}
         */
        Tip.prototype.address;
        /**
         * 城市
         * @type {?}
         */
        Tip.prototype.city;
        /**
         * ID
         * @type {?}
         */
        Tip.prototype.id;
        /**
         * 坐标经纬度
         * @type {?}
         */
        Tip.prototype.location;
        /**
         * 类型编码
         * @type {?}
         */
        Tip.prototype.typecode;
    }
    /**
     * @record
     */
    function SearchResult() { }
    AMapAutocomplete.SearchResult = SearchResult;
    if (false) {
        /**
         * 查询状态说明
         * @type {?}
         */
        SearchResult.prototype.info;
        /**
         * 输入提示条数
         * @type {?}
         */
        SearchResult.prototype.count;
        /**
         * 输入提示列表
         * @type {?}
         */
        SearchResult.prototype.tips;
    }
})(AMapAutocomplete || (AMapAutocomplete = {}));
/**
 * @record
 */
function AutocompleteSearchResult() { }
if (false) {
    /** @type {?} */
    AutocompleteSearchResult.prototype.status;
    /** @type {?} */
    AutocompleteSearchResult.prototype.result;
}
class AmapAutocompleteService {
    /**
     * @param {?} plugin
     * @param {?} binder
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(plugin, binder, logger, ngZone) {
        this.plugin = plugin;
        this.binder = binder;
        this.logger = logger;
        this.ngZone = ngZone;
        this.ac$ = new ReplaySubject(1);
    }
    /**
     * 获取插件
     * @return {?}
     */
    get() {
        return this.ac$.asObservable();
    }
    /**
     * 侦听事件
     * @param {?} event
     * @return {?}
     */
    on(event) {
        return this.binder.bindEvent(this.get(), event);
    }
    /**
     * 创建插件
     * @param {?} options
     * @return {?}
     */
    create(options) {
        return this.plugin.load('AMap.Autocomplete').pipe(map((/**
         * @return {?}
         */
        () => {
            this.ac = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AMap.Autocomplete(options)));
            this.logger.d(TAG$w, 'new autocomplete created.');
            this.ac$.next(this.ac);
            this.ac$.complete();
            return this.ac;
        })));
    }
    /**
     * 搜索
     * @param {?} address
     * @return {?}
     */
    search(address) {
        return this.get().pipe(switchMap((/**
         * @param {?} ac
         * @return {?}
         */
        ac => new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            ac.search(address, (/**
             * @param {?} status
             * @param {?} result
             * @return {?}
             */
            (status, result) => {
                observer.next({ status, result });
                observer.complete();
            }));
        })))));
    }
}
AmapAutocompleteService.ɵfac = function AmapAutocompleteService_Factory(t) { return new (t || AmapAutocompleteService)(ɵngcc0.ɵɵinject(AmapPluginLoaderService), ɵngcc0.ɵɵinject(EventBinderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
AmapAutocompleteService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapAutocompleteService, factory: AmapAutocompleteService.ɵfac, providedIn: 'root' });
/** @nocollapse */
AmapAutocompleteService.ctorParameters = () => [
    { type: AmapPluginLoaderService },
    { type: EventBinderService },
    { type: LoggerService },
    { type: NgZone }
];
/** @nocollapse */ AmapAutocompleteService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AmapAutocompleteService_Factory() { return new AmapAutocompleteService(ɵɵinject(AmapPluginLoaderService), ɵɵinject(EventBinderService), ɵɵinject(LoggerService), ɵɵinject(NgZone)); }, token: AmapAutocompleteService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapAutocompleteService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AmapPluginLoaderService }, { type: EventBinderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapAutocompleteService.prototype.ac;
    /**
     * @type {?}
     * @private
     */
    AmapAutocompleteService.prototype.ac$;
    /**
     * @type {?}
     * @private
     */
    AmapAutocompleteService.prototype.plugin;
    /**
     * @type {?}
     * @private
     */
    AmapAutocompleteService.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    AmapAutocompleteService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    AmapAutocompleteService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/input-amap-autocomplete/input-amap-autocomplete.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$x = 'amap-autocomplete';
/** @type {?} */
const AutocompleteOptions = ['type', 'city', 'datatype', 'citylimit'];
class InputAmapAutocompleteDirective {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} el
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, el, logger, ngZone) {
        this.os = os;
        this.binder = binder;
        this.el = el;
        this.logger = logger;
        this.ngZone = ngZone;
        // ---- Events ----
        this.naReady = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        const target = this.os.get();
        this.naComplete = this.binder.bindEvent(target, 'complete');
        this.naSelect = this.binder.bindEvent(target, 'select');
        this.naChoose = this.binder.bindEvent(target, 'choose');
        this.naError = this.binder.bindEvent(target, 'error');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const plugin = this.os.get();
        if (!this.inited) {
            this.logger.d(TAG$x, 'initializing ...');
            /** @type {?} */
            const options = getOptions(this, AutocompleteOptions);
            options.input = this.el.nativeElement;
            this.logger.d(TAG$x, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.naReady.emit(m)));
                this.logger.d(TAG$x, 'autocomplete is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('city'), plugin).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setCity(v)));
            zip(filter.has('type'), plugin).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setType(v)));
            zip(filter.has('citylimit'), plugin).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, p]) => p.setCityLimit(v)));
        }
    }
}
InputAmapAutocompleteDirective.ɵfac = function InputAmapAutocompleteDirective_Factory(t) { return new (t || InputAmapAutocompleteDirective)(ɵngcc0.ɵɵdirectiveInject(AmapAutocompleteService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
InputAmapAutocompleteDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: InputAmapAutocompleteDirective, selectors: [["input", "amapAutocomplete", ""]], inputs: { type: "type", city: "city", datatype: "datatype", citylimit: "citylimit" }, outputs: { naReady: "naReady", naComplete: "naComplete", naSelect: "naSelect", naChoose: "naChoose", naError: "naError" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
InputAmapAutocompleteDirective.ctorParameters = () => [
    { type: AmapAutocompleteService },
    { type: EventBinderService },
    { type: ElementRef },
    { type: LoggerService },
    { type: NgZone }
];
InputAmapAutocompleteDirective.propDecorators = {
    type: [{ type: Input }],
    city: [{ type: Input }],
    datatype: [{ type: Input }],
    citylimit: [{ type: Input }],
    naReady: [{ type: Output }],
    naComplete: [{ type: Output }],
    naSelect: [{ type: Output }],
    naChoose: [{ type: Output }],
    naError: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InputAmapAutocompleteDirective, [{
        type: Directive,
        args: [{
                selector: 'input[amapAutocomplete]'
            }]
    }], function () { return [{ type: AmapAutocompleteService }, { type: EventBinderService }, { type: ɵngcc0.ElementRef }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { naReady: [{
            type: Output
        }], naComplete: [{
            type: Output
        }], naSelect: [{
            type: Output
        }], naChoose: [{
            type: Output
        }], naError: [{
            type: Output
        }], type: [{
            type: Input
        }], city: [{
            type: Input
        }], datatype: [{
            type: Input
        }], citylimit: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * 输入提示时限定POI类型，多个类型用“|”分隔
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.type;
    /**
     * 输入提示时限定城市
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.city;
    /**
     * 返回的数据类型
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.datatype;
    /**
     * 是否强制限制在设置的城市内搜索
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.citylimit;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naReady;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naComplete;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naSelect;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naChoose;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naError;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    InputAmapAutocompleteDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    InputAmapAutocompleteDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: shared/amap-ui-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TAG$y = 'AMapUILoader';
class AmapUILoaderService {
    /**
     * @param {?} amap
     * @param {?} logger
     */
    constructor(amap, logger) {
        this.amap = amap;
        this.logger = logger;
        this.state = new Map();
    }
    /**
     * @param {?} name
     * @return {?}
     */
    load(name) {
        /** @type {?} */
        let pKey = '';
        if (Array.isArray(name)) {
            pKey = name.join(',');
        }
        else {
            pKey = name;
        }
        if (this.state.has(pKey)) {
            return this.state.get(pKey).asObservable();
        }
        this.logger.d(TAG$y, 'loading ui:', pKey, '...');
        /** @type {?} */
        const loading$ = new ReplaySubject(1);
        this.amap.load().subscribe({
            next: (/**
             * @return {?}
             */
            () => {
                this.amap.loadUI().subscribe({
                    next: (/**
                     * @return {?}
                     */
                    () => {
                        AMapUI.loadUI(Array.isArray(name) ? name : [name], (/**
                         * @param {?} u
                         * @return {?}
                         */
                        u => {
                            this.logger.d(TAG$y, 'loading ui:', pKey, 'COMPLETE');
                            loading$.next(u);
                            loading$.complete();
                        }));
                        this.state.set(pKey, loading$);
                    }),
                });
            }),
        });
        return loading$.asObservable();
    }
}
AmapUILoaderService.ɵfac = function AmapUILoaderService_Factory(t) { return new (t || AmapUILoaderService)(ɵngcc0.ɵɵinject(AMapLoaderService), ɵngcc0.ɵɵinject(LoggerService)); };
AmapUILoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AmapUILoaderService, factory: AmapUILoaderService.ɵfac });
/** @nocollapse */
AmapUILoaderService.ctorParameters = () => [
    { type: AMapLoaderService },
    { type: LoggerService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AmapUILoaderService, [{
        type: Injectable
    }], function () { return [{ type: AMapLoaderService }, { type: LoggerService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AmapUILoaderService.prototype.state;
    /**
     * @type {?}
     * @private
     */
    AmapUILoaderService.prototype.amap;
    /**
     * @type {?}
     * @private
     */
    AmapUILoaderService.prototype.logger;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/ui-simple-marker/ui-simple-marker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AMapUISimpleMarker;
(function (AMapUISimpleMarker) {
    /**
     * @record
     * @template ExtraData
     */
    function Options() { }
    AMapUISimpleMarker.Options = Options;
    if (false) {
        /**
         * 样式主题
         * @type {?|undefined}
         */
        Options.prototype.iconTheme;
        /**
         * 背景图标样式
         * @type {?|undefined}
         */
        Options.prototype.iconStyle;
        /**
         * 图标前景文字
         * @type {?|undefined}
         */
        Options.prototype.iconLabel;
        /**
         * 是否显示定位点
         * @type {?|undefined}
         */
        Options.prototype.showPositionPoint;
        /**
         * 内建的Dom容器上附带的class，多个class name用空格分开
         * @type {?|undefined}
         */
        Options.prototype.containerClassNames;
    }
})(AMapUISimpleMarker || (AMapUISimpleMarker = {}));
/** @type {?} */
const TAG$z = 'UISimpleMarker';
class UISimpleMarkerService {
    /**
     * @param {?} amaps
     * @param {?} uiLoader
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, uiLoader, logger, ngZone) {
        this.amaps = amaps;
        this.uiLoader = uiLoader;
        this.logger = logger;
        this.ngZone = ngZone;
        this.marker$ = new ReplaySubject(1);
        this.ui = (/** @type {?} */ (this.uiLoader.load('overlay/SimpleMarker')));
    }
    /**
     * 获取点标记
     * @return {?}
     */
    get() {
        return this.marker$.asObservable();
    }
    /**
     * 创建点标记 AMap.SimpleMarker
     * @param {?} options 选项
     * @param {?=} addToMap 是否直接加进地图
     * @return {?}
     */
    create(options, addToMap = true) {
        return zip(this.ui, this.amaps.get()).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([SimpleMarker, m]) => {
            if (addToMap) {
                options.map = m;
            }
            this.marker = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new SimpleMarker(options)));
            this.logger.d(TAG$z, 'new simple marker created.');
            this.marker$.next(this.marker);
            this.marker$.complete();
            return this.marker;
        })));
    }
    /**
     * 销毁点标记
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$z, 'simple marker destroyed.');
            this.marker = null;
        }));
    }
}
UISimpleMarkerService.ɵfac = function UISimpleMarkerService_Factory(t) { return new (t || UISimpleMarkerService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(AmapUILoaderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
UISimpleMarkerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UISimpleMarkerService, factory: UISimpleMarkerService.ɵfac });
/** @nocollapse */
UISimpleMarkerService.ctorParameters = () => [
    { type: AMapService },
    { type: AmapUILoaderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UISimpleMarkerService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: AmapUILoaderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.marker;
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.marker$;
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.ui;
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.uiLoader;
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    UISimpleMarkerService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/ui-simple-marker/ui-simple-marker.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SimpleMarkerOptions = [
    ...OverlayOptions,
    // Marker options without cotent
    'position',
    'anchor',
    'offset',
    'icon',
    'topWhenClick',
    'raiseOnDrag',
    'visible',
    'zIndex',
    'angle',
    'autoRotation',
    'animation',
    'shadow',
    'title',
    'shape',
    'label',
    // Own options
    'iconTheme',
    'iconStyle',
    'iconLabel',
    'showPositionPoint',
    'containerClassNames',
];
class UISimpleMarker extends AMapOverlay {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} pixels
     * @param {?} icons
     * @param {?} mlabels
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, pixels, icons, mlabels, logger, ngZone) {
        super(os, binder);
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.pixels = pixels;
        this.icons = icons;
        this.mlabels = mlabels;
        this.logger = logger;
        this.ngZone = ngZone;
        this.TAG = 'ui-simple-marker';
        /**
         * 额外: 是否隐藏
         */
        this.hidden = false;
        /**
         * 额外: 是否包含在点聚合中
         */
        this.inCluster = false;
        /**
         * 额外: 点击时是否显示信息窗体
         */
        this.openInfoWindow = true;
        // amap-marker events:
        this.naReady = new EventEmitter();
        // amap info window:
        this.infoWindowComponent = new QueryList();
        this.inited = false;
        /** @type {?} */
        const target = this.os.get();
        this.naMouseOut = this.binder.bindEvent(target, 'mouseout');
        this.naDragStart = this.binder.bindEvent(target, 'dragstart');
        this.naDragging = this.binder.bindEvent(target, 'dragging');
        this.naDragEnd = this.binder.bindEvent(target, 'dragend');
        this.naMoving = this.binder.bindEvent(target, 'moving');
        this.naMoveEnd = this.binder.bindEvent(target, 'moveend');
        this.naMoveAlong = this.binder.bindEvent(target, 'movealong');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.os.destroy();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const marker = this.get();
        if (!this.inited) {
            // do not draw marker when no poistion defined.
            if (!this.position) {
                return;
            }
            this.amaps.get().subscribe((/**
             * @return {?}
             */
            () => {
                this.logger.d(this.TAG, 'initializing ...');
                // bind info window events:
                this.subscription = this.binder.bindEvent(marker, 'click').subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.openInfoWindow) {
                        this.infoWindowComponent.forEach((/**
                         * @param {?} w
                         * @return {?}
                         */
                        w => w.open()));
                    }
                }));
                /** @type {?} */
                const options = this.getOptions();
                if (this.icon) {
                    options.icon = this.icons.create(this.icon);
                }
                if (this.shadow) {
                    options.shadow = this.icons.create(this.shadow);
                }
                if (this.label) {
                    options.label = this.mlabels.create(this.label);
                }
                if (this.offset) {
                    options.offset = this.pixels.create(this.offset);
                }
                this.logger.d(this.TAG, 'options:', options);
                this.os.create(options).subscribe((/**
                 * @param {?} m
                 * @return {?}
                 */
                m => {
                    this.ngZone.run((/**
                     * @return {?}
                     */
                    () => this.naReady.emit(m)));
                    this.logger.d(this.TAG, 'marker is ready.');
                }));
                this.inited = true;
                this.updateInfoWindow();
                this.updateInfoWindowPosition();
            }));
        }
        else {
            zip(filter.has('icon'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setIcon(this.icons.create(v))));
            zip(filter.has('shadow'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setShadow(this.icons.create(v))));
            zip(filter.has('label'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setLabel(this.mlabels.create(v))));
            zip(filter.has('title'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setTitle(v)));
            zip(filter.has('extData'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setExtData(v)));
            zip(filter.has('clickable'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setClickable(!!v)));
            zip(filter.has('draggable'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setDraggable(!!v)));
            zip(filter.has('visible'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => (v ? m.show() : m.hide())));
            zip(filter.has('cursor'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setCursor(v)));
            zip(filter.has('animation'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAnimation(v)));
            zip(filter.has('angle'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAngle(v)));
            zip(filter.has('zIndex'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setzIndex(v)));
            zip(filter.has('shape'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setShape(v)));
            zip(filter.notEmpty('offset'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setOffset(this.pixels.create(v))));
            zip(filter.notEmpty('position'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setPosition(v)));
            zip(filter.has('showPositionPoint'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => {
                if (!!v) {
                    m.showPositionPoint();
                }
                else {
                    m.hidePositionPoint();
                }
            }));
            zip(filter.notEmpty('iconStyle'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => {
                if (changes.iconTheme && changes.iconTheme.currentValue) {
                    m.setIconThemeAndStyle(changes.iconTheme.currentValue, v);
                }
                else {
                    m.setIconStyle(v);
                }
            }));
            zip(filter.notEmpty('iconLabel'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setIconLabel(v)));
            zip(filter.notEmpty('containerClassNames'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setContainerClassNames(v)));
        }
        zip(filter.has('isTop'), marker).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => m.setTop(!!v)));
        zip(filter.has('hidden'), marker).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([v, m]) => (v ? m.hide() : m.show())));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateInfoWindow();
        this.infoWindowComponent.changes.subscribe((/**
         * @return {?}
         */
        () => this.updateInfoWindow()));
    }
    /**
     * @private
     * @return {?}
     */
    updateInfoWindow() {
        if (this.infoWindowComponent && this.inited) {
            if (this.infoWindowComponent.length > 1) {
                this.logger.e(this.TAG, 'Expected no more than 1 info window.');
                return;
            }
            /** @type {?} */
            const marker = this.os.get();
            this.infoWindowComponent.forEach((/**
             * @param {?} component
             * @return {?}
             */
            component => {
                component.hostMarker = marker;
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInfoWindowPosition() {
        if (this.infoWindowComponent && this.inited) {
            this.infoWindowComponent.forEach((/**
             * @param {?} component
             * @return {?}
             */
            component => {
                component.toggleOpen();
            }));
        }
    }
    /**
     * @return {?}
     */
    getOptions() {
        return getOptions(this, SimpleMarkerOptions);
    }
    /**
     * 获取已创建的 AMapUI 对象
     * @return {?}
     */
    get() {
        return this.os.get();
    }
}
UISimpleMarker.ɵfac = function UISimpleMarker_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
UISimpleMarker.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UISimpleMarker, contentQueries: function UISimpleMarker_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AmapInfoWindowComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.infoWindowComponent = _t);
    } }, inputs: { hidden: "hidden", inCluster: "inCluster", openInfoWindow: "openInfoWindow", iconTheme: "iconTheme", iconStyle: "iconStyle", iconLabel: "iconLabel", showPositionPoint: "showPositionPoint", containerClassNames: "containerClassNames", position: "position", anchor: "anchor", offset: "offset", icon: "icon", topWhenClick: "topWhenClick", raiseOnDrag: "raiseOnDrag", visible: "visible", zIndex: "zIndex", angle: "angle", autoRotation: "autoRotation", animation: "animation", shadow: "shadow", title: "title", shape: "shape", label: "label", isTop: "isTop" }, outputs: { naReady: "naReady", naMouseOut: "naMouseOut", naDragStart: "naDragStart", naDragging: "naDragging", naDragEnd: "naDragEnd", naMoving: "naMoving", naMoveEnd: "naMoveEnd", naMoveAlong: "naMoveAlong" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
UISimpleMarker.propDecorators = {
    iconTheme: [{ type: Input }],
    iconStyle: [{ type: Input }],
    iconLabel: [{ type: Input }],
    showPositionPoint: [{ type: Input }],
    containerClassNames: [{ type: Input }],
    position: [{ type: Input }],
    anchor: [{ type: Input }],
    offset: [{ type: Input }],
    icon: [{ type: Input }],
    topWhenClick: [{ type: Input }],
    raiseOnDrag: [{ type: Input }],
    visible: [{ type: Input }],
    zIndex: [{ type: Input }],
    angle: [{ type: Input }],
    autoRotation: [{ type: Input }],
    animation: [{ type: Input }],
    shadow: [{ type: Input }],
    title: [{ type: Input }],
    shape: [{ type: Input }],
    label: [{ type: Input }],
    isTop: [{ type: Input }],
    hidden: [{ type: Input }],
    inCluster: [{ type: Input }],
    openInfoWindow: [{ type: Input }],
    naReady: [{ type: Output }],
    naMouseOut: [{ type: Output }],
    naDragStart: [{ type: Output }],
    naDragging: [{ type: Output }],
    naDragEnd: [{ type: Output }],
    naMoving: [{ type: Output }],
    naMoveEnd: [{ type: Output }],
    naMoveAlong: [{ type: Output }],
    infoWindowComponent: [{ type: ContentChildren, args: [AmapInfoWindowComponent,] }]
};

if (false) {
    /** @type {?} */
    UISimpleMarker.prototype.TAG;
    /**
     * 样式主题
     * @type {?}
     */
    UISimpleMarker.prototype.iconTheme;
    /**
     * 背景图标样式
     * @type {?}
     */
    UISimpleMarker.prototype.iconStyle;
    /**
     * 图标前景文字
     * @type {?}
     */
    UISimpleMarker.prototype.iconLabel;
    /**
     * 是否显示定位点
     * @type {?}
     */
    UISimpleMarker.prototype.showPositionPoint;
    /**
     * 内建的Dom容器上附带的class，多个class name用空格分开
     * @type {?}
     */
    UISimpleMarker.prototype.containerClassNames;
    /**
     * 点标记在地图上显示的位置
     * @type {?}
     */
    UISimpleMarker.prototype.position;
    /**
     * 标记锚点
     * @type {?}
     */
    UISimpleMarker.prototype.anchor;
    /**
     * 点标记显示位置偏移量
     * @type {?}
     */
    UISimpleMarker.prototype.offset;
    /**
     * 需在点标记中显示的图标
     * @type {?}
     */
    UISimpleMarker.prototype.icon;
    /**
     * 鼠标点击时marker是否置顶
     * @type {?}
     */
    UISimpleMarker.prototype.topWhenClick;
    /**
     * 拖拽点标记时是否开启点标记离开地图的效果
     * @type {?}
     */
    UISimpleMarker.prototype.raiseOnDrag;
    /**
     * 点标记是否可见
     * @type {?}
     */
    UISimpleMarker.prototype.visible;
    /**
     * 点标记的叠加顺序
     * @type {?}
     */
    UISimpleMarker.prototype.zIndex;
    /**
     * 点标记的旋转角度
     * @type {?}
     */
    UISimpleMarker.prototype.angle;
    /**
     * 是否自动旋转
     * @type {?}
     */
    UISimpleMarker.prototype.autoRotation;
    /**
     * 点标记的动画效果
     * @type {?}
     */
    UISimpleMarker.prototype.animation;
    /**
     * 点标记阴影
     * @type {?}
     */
    UISimpleMarker.prototype.shadow;
    /**
     * 鼠标滑过点标记时的文字提示
     * @type {?}
     */
    UISimpleMarker.prototype.title;
    /**
     * 可点击区域
     * @type {?}
     */
    UISimpleMarker.prototype.shape;
    /**
     * 文本标注
     * @type {?}
     */
    UISimpleMarker.prototype.label;
    /**
     * 额外: 是否置顶
     * @type {?}
     */
    UISimpleMarker.prototype.isTop;
    /**
     * 额外: 是否隐藏
     * @type {?}
     */
    UISimpleMarker.prototype.hidden;
    /**
     * 额外: 是否包含在点聚合中
     * @type {?}
     */
    UISimpleMarker.prototype.inCluster;
    /**
     * 额外: 点击时是否显示信息窗体
     * @type {?}
     */
    UISimpleMarker.prototype.openInfoWindow;
    /** @type {?} */
    UISimpleMarker.prototype.naReady;
    /** @type {?} */
    UISimpleMarker.prototype.naMouseOut;
    /** @type {?} */
    UISimpleMarker.prototype.naDragStart;
    /** @type {?} */
    UISimpleMarker.prototype.naDragging;
    /** @type {?} */
    UISimpleMarker.prototype.naDragEnd;
    /** @type {?} */
    UISimpleMarker.prototype.naMoving;
    /** @type {?} */
    UISimpleMarker.prototype.naMoveEnd;
    /** @type {?} */
    UISimpleMarker.prototype.naMoveAlong;
    /** @type {?} */
    UISimpleMarker.prototype.infoWindowComponent;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.subscription;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.binder;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.amaps;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.pixels;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.icons;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.mlabels;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.logger;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarker.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/ui-simple-marker/ui-simple-marker.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UISimpleMarkerDirective extends UISimpleMarker {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} pixels
     * @param {?} icons
     * @param {?} mlabels
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, pixels, icons, mlabels, logger, ngZone) {
        super(os, binder, amaps, pixels, icons, mlabels, logger, ngZone);
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.pixels = pixels;
        this.icons = icons;
        this.mlabels = mlabels;
        this.logger = logger;
        this.ngZone = ngZone;
    }
}
UISimpleMarkerDirective.ɵfac = function UISimpleMarkerDirective_Factory(t) { return new (t || UISimpleMarkerDirective)(ɵngcc0.ɵɵdirectiveInject(UISimpleMarkerService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(IconService), ɵngcc0.ɵɵdirectiveInject(MarkerLabelService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
UISimpleMarkerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UISimpleMarkerDirective, selectors: [["ui-simple-marker"]], exportAs: ["simpleMarker"], features: [ɵngcc0.ɵɵProvidersFeature([UISimpleMarkerService]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
UISimpleMarkerDirective.ctorParameters = () => [
    { type: UISimpleMarkerService },
    { type: EventBinderService },
    { type: AMapService },
    { type: PixelService },
    { type: IconService },
    { type: MarkerLabelService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UISimpleMarkerDirective, [{
        type: Directive,
        args: [{
                selector: 'ui-simple-marker',
                exportAs: 'simpleMarker',
                providers: [UISimpleMarkerService]
            }]
    }], function () { return [{ type: UISimpleMarkerService }, { type: EventBinderService }, { type: AMapService }, { type: PixelService }, { type: IconService }, { type: MarkerLabelService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.binder;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.amaps;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.pixels;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.icons;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.mlabels;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.logger;
    /**
     * @type {?}
     * @protected
     */
    UISimpleMarkerDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/ui-awesome-marker/ui-awesome-marker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AMapUIAwesomeMarker;
(function (AMapUIAwesomeMarker) {
    /**
     * @record
     * @template ExtraData
     */
    function Options() { }
    AMapUIAwesomeMarker.Options = Options;
    if (false) {
        /**
         * icon 的名称，可用的 icons 参见 Font Awesome 官网
         * @type {?|undefined}
         */
        Options.prototype.awesomeIcon;
        /**
         * 返回字体节点上的 classNames
         * @type {?|undefined}
         */
        Options.prototype.getClassnamesOfAwesomeIcon;
    }
})(AMapUIAwesomeMarker || (AMapUIAwesomeMarker = {}));
/** @type {?} */
const TAG$A = 'UIAwesomeMarker';
class UIAwesomeMarkerService {
    /**
     * @param {?} amaps
     * @param {?} uiLoader
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(amaps, uiLoader, logger, ngZone) {
        this.amaps = amaps;
        this.uiLoader = uiLoader;
        this.logger = logger;
        this.ngZone = ngZone;
        this.marker$ = new ReplaySubject(1);
        this.ui = (/** @type {?} */ (this.uiLoader.load('overlay/AwesomeMarker')));
    }
    /**
     * 获取点标记
     * @return {?}
     */
    get() {
        return this.marker$.asObservable();
    }
    /**
     * 创建点标记 AMap.AwesomeMarker
     * @param {?} options 选项
     * @param {?=} addToMap 是否直接加进地图
     * @return {?}
     */
    create(options, addToMap = true) {
        return zip(this.ui, this.amaps.get()).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([AwesomeMarker, m]) => {
            if (addToMap) {
                options.map = m;
            }
            this.marker = this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => new AwesomeMarker(options)));
            this.logger.d(TAG$A, 'new awesome marker created.');
            this.marker$.next(this.marker);
            this.marker$.complete();
            return this.marker;
        })));
    }
    /**
     * 销毁点标记
     * @return {?}
     */
    destroy() {
        this.get().subscribe((/**
         * @param {?} m
         * @return {?}
         */
        m => {
            m.setMap(null);
            this.logger.d(TAG$A, 'awesome marker destroyed.');
            this.marker = null;
        }));
    }
}
UIAwesomeMarkerService.ɵfac = function UIAwesomeMarkerService_Factory(t) { return new (t || UIAwesomeMarkerService)(ɵngcc0.ɵɵinject(AMapService), ɵngcc0.ɵɵinject(AmapUILoaderService), ɵngcc0.ɵɵinject(LoggerService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
UIAwesomeMarkerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UIAwesomeMarkerService, factory: UIAwesomeMarkerService.ɵfac });
/** @nocollapse */
UIAwesomeMarkerService.ctorParameters = () => [
    { type: AMapService },
    { type: AmapUILoaderService },
    { type: LoggerService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UIAwesomeMarkerService, [{
        type: Injectable
    }], function () { return [{ type: AMapService }, { type: AmapUILoaderService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.marker;
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.marker$;
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.ui;
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.amaps;
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.uiLoader;
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    UIAwesomeMarkerService.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: directives/ui-awesome-marker/ui-awesome-marker.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const AwesomeMarkerOptions = [...SimpleMarkerOptions, 'awesomeIcon', 'getClassnamesOfAwesomeIcon'];
class UIAwesomeMarkerDirective extends UISimpleMarker {
    /**
     * @param {?} os
     * @param {?} binder
     * @param {?} amaps
     * @param {?} pixels
     * @param {?} icons
     * @param {?} mlabels
     * @param {?} logger
     * @param {?} ngZone
     */
    constructor(os, binder, amaps, pixels, icons, mlabels, logger, ngZone) {
        super(os, binder, amaps, pixels, icons, mlabels, logger, ngZone);
        this.os = os;
        this.binder = binder;
        this.amaps = amaps;
        this.pixels = pixels;
        this.icons = icons;
        this.mlabels = mlabels;
        this.logger = logger;
        this.ngZone = ngZone;
        this.TAG = 'ui-awesome-marker';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        /** @type {?} */
        const marker = this.get();
        if (this.inited) {
            zip(filter.has('awesomeIcon'), marker).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ([v, m]) => m.setAwesomeIcon(v)));
        }
    }
    /**
     * @return {?}
     */
    getOptions() {
        return getOptions(this, AwesomeMarkerOptions);
    }
}
UIAwesomeMarkerDirective.ɵfac = function UIAwesomeMarkerDirective_Factory(t) { return new (t || UIAwesomeMarkerDirective)(ɵngcc0.ɵɵdirectiveInject(UIAwesomeMarkerService), ɵngcc0.ɵɵdirectiveInject(EventBinderService), ɵngcc0.ɵɵdirectiveInject(AMapService), ɵngcc0.ɵɵdirectiveInject(PixelService), ɵngcc0.ɵɵdirectiveInject(IconService), ɵngcc0.ɵɵdirectiveInject(MarkerLabelService), ɵngcc0.ɵɵdirectiveInject(LoggerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
UIAwesomeMarkerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UIAwesomeMarkerDirective, selectors: [["ui-awesome-marker"]], inputs: { awesomeIcon: "awesomeIcon", getClassnamesOfAwesomeIcon: "getClassnamesOfAwesomeIcon" }, exportAs: ["awesomeMarker"], features: [ɵngcc0.ɵɵProvidersFeature([UIAwesomeMarkerService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
UIAwesomeMarkerDirective.ctorParameters = () => [
    { type: UIAwesomeMarkerService },
    { type: EventBinderService },
    { type: AMapService },
    { type: PixelService },
    { type: IconService },
    { type: MarkerLabelService },
    { type: LoggerService },
    { type: NgZone }
];
UIAwesomeMarkerDirective.propDecorators = {
    awesomeIcon: [{ type: Input }],
    getClassnamesOfAwesomeIcon: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UIAwesomeMarkerDirective, [{
        type: Directive,
        args: [{
                selector: 'ui-awesome-marker',
                exportAs: 'awesomeMarker',
                providers: [UIAwesomeMarkerService]
            }]
    }], function () { return [{ type: UIAwesomeMarkerService }, { type: EventBinderService }, { type: AMapService }, { type: PixelService }, { type: IconService }, { type: MarkerLabelService }, { type: LoggerService }, { type: ɵngcc0.NgZone }]; }, { awesomeIcon: [{
            type: Input
        }], getClassnamesOfAwesomeIcon: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    UIAwesomeMarkerDirective.prototype.TAG;
    /**
     * icon 的名称，可用的 icons 参见 Font Awesome 官网
     * @type {?}
     */
    UIAwesomeMarkerDirective.prototype.awesomeIcon;
    /**
     * 返回字体节点上的 classNames
     * @type {?}
     */
    UIAwesomeMarkerDirective.prototype.getClassnamesOfAwesomeIcon;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.binder;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.amaps;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.pixels;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.icons;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.mlabels;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.logger;
    /**
     * @type {?}
     * @protected
     */
    UIAwesomeMarkerDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-amap.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxAmapModule {
    /**
     * @param {?=} mapConfig
     * @return {?}
     */
    static forRoot(mapConfig) {
        return {
            ngModule: NgxAmapModule,
            providers: [
                { provide: NGX_AMAP_CONFIG, useValue: mapConfig || {} },
                {
                    provide: LoggerService,
                    useClass: mapConfig && mapConfig.debug ? DebugLoggerService : LoggerService,
                },
                AMapLoaderService,
                AmapPluginLoaderService,
                AmapUILoaderService,
                EventBinderService,
            ],
        };
    }
}
NgxAmapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxAmapModule });
NgxAmapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxAmapModule_Factory(t) { return new (t || NgxAmapModule)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxAmapModule, { declarations: [NgxAmapComponent,
        AmapMarkerDirective,
        AmapPolylineDirective,
        AmapInfoWindowComponent,
        AmapTextComponent,
        AmapPolygonDirective,
        AmapBezierCurveDirective,
        AmapRectangleDirective,
        AmapCircleDirective,
        AmapCircleMarkerDirective,
        AmapEllipseDirective,
        AmapToolBarDirective,
        AmapMarkerClustererDirective,
        AmapHeatmapDirective,
        InputAmapAutocompleteDirective,
        UISimpleMarkerDirective,
        UIAwesomeMarkerDirective], exports: [NgxAmapComponent,
        AmapMarkerDirective,
        AmapPolylineDirective,
        AmapInfoWindowComponent,
        AmapTextComponent,
        AmapPolygonDirective,
        AmapBezierCurveDirective,
        AmapRectangleDirective,
        AmapCircleDirective,
        AmapCircleMarkerDirective,
        AmapEllipseDirective,
        AmapToolBarDirective,
        AmapMarkerClustererDirective,
        AmapHeatmapDirective,
        InputAmapAutocompleteDirective,
        UISimpleMarkerDirective,
        UIAwesomeMarkerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxAmapModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    NgxAmapComponent,
                    AmapMarkerDirective,
                    AmapPolylineDirective,
                    AmapInfoWindowComponent,
                    AmapTextComponent,
                    AmapPolygonDirective,
                    AmapBezierCurveDirective,
                    AmapRectangleDirective,
                    AmapCircleDirective,
                    AmapCircleMarkerDirective,
                    AmapEllipseDirective,
                    AmapToolBarDirective,
                    AmapMarkerClustererDirective,
                    AmapHeatmapDirective,
                    InputAmapAutocompleteDirective,
                    UISimpleMarkerDirective,
                    UIAwesomeMarkerDirective,
                ],
                imports: [],
                exports: [
                    NgxAmapComponent,
                    AmapMarkerDirective,
                    AmapPolylineDirective,
                    AmapInfoWindowComponent,
                    AmapTextComponent,
                    AmapPolygonDirective,
                    AmapBezierCurveDirective,
                    AmapRectangleDirective,
                    AmapCircleDirective,
                    AmapCircleMarkerDirective,
                    AmapEllipseDirective,
                    AmapToolBarDirective,
                    AmapMarkerClustererDirective,
                    AmapHeatmapDirective,
                    InputAmapAutocompleteDirective,
                    UISimpleMarkerDirective,
                    UIAwesomeMarkerDirective,
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-amap.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AMapLoaderService, AmapAutocompleteService, AmapBezierCurveDirective, AmapCircleDirective, AmapCircleMarkerDirective, AmapEllipseDirective, AmapHeatmapDirective, AmapInfoWindowComponent, AmapMarkerClustererDirective, AmapMarkerDirective, AmapPluginLoaderService, AmapPolygonDirective, AmapPolylineDirective, AmapRectangleDirective, AmapTextComponent, AmapToolBarDirective, AmapUILoaderService, EventBinderService, InputAmapAutocompleteDirective, NgxAmapComponent, NgxAmapModule, UIAwesomeMarkerDirective, UISimpleMarkerDirective, AMapService as ɵa, AmapEllipseService as ɵba, AmapToolBarService as ɵbb, AmapMarkerClustererService as ɵbc, AmapHeatmapService as ɵbd, UISimpleMarker as ɵbe, UISimpleMarkerService as ɵbf, UIAwesomeMarkerService as ɵbg, DebugLoggerService as ɵbh, NGX_AMAP_CONFIG as ɵc, LoggerService as ɵd, PluginLoaderService as ɵe, AMapOverlay as ɵf, AmapMarkerService as ɵj, AmapInfoWindowService as ɵk, PixelService as ɵl, SizeService as ɵm, IconService as ɵn, MarkerLabelService as ɵo, AMapPathOverlay as ɵp, AMapShapeOverlay as ɵq, AmapPolylineService as ɵr, AmapTextService as ɵs, AMapPolygon as ɵt, AmapPolygonService as ɵu, AmapBezierCurveService as ɵv, AmapRectangleService as ɵw, AMapCircle as ɵx, AmapCircleService as ɵy, AmapCircleMarkerService as ɵz };

//# sourceMappingURL=ngx-amap.js.map