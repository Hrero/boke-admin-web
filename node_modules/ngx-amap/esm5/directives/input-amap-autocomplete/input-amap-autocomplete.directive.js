/**
 * @fileoverview added by tsickle
 * Generated from: directives/input-amap-autocomplete/input-amap-autocomplete.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Input, Output, EventEmitter, Directive, ElementRef, NgZone, } from '@angular/core';
import { zip } from 'rxjs';
import { AmapAutocompleteService, } from '../../services/amap-autocomplete/amap-autocomplete.service';
import { LoggerService } from '../../shared/logger/logger.service';
import { EventBinderService } from '../../shared/event-binder.service';
import { getOptions, ChangeFilter } from '../../utils';
/** @type {?} */
var TAG = 'amap-autocomplete';
/** @type {?} */
var AutocompleteOptions = ['type', 'city', 'datatype', 'citylimit'];
var InputAmapAutocompleteDirective = /** @class */ (function () {
    function InputAmapAutocompleteDirective(os, binder, el, logger, ngZone) {
        this.os = os;
        this.binder = binder;
        this.el = el;
        this.logger = logger;
        this.ngZone = ngZone;
        // ---- Events ----
        this.naReady = new EventEmitter();
        this.inited = false;
        /** @type {?} */
        var target = this.os.get();
        this.naComplete = this.binder.bindEvent(target, 'complete');
        this.naSelect = this.binder.bindEvent(target, 'select');
        this.naChoose = this.binder.bindEvent(target, 'choose');
        this.naError = this.binder.bindEvent(target, 'error');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    InputAmapAutocompleteDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        /** @type {?} */
        var filter = ChangeFilter.of(changes);
        /** @type {?} */
        var plugin = this.os.get();
        if (!this.inited) {
            this.logger.d(TAG, 'initializing ...');
            /** @type {?} */
            var options = getOptions(this, AutocompleteOptions);
            options.input = this.el.nativeElement;
            this.logger.d(TAG, 'options:', options);
            this.os.create(options).subscribe((/**
             * @param {?} m
             * @return {?}
             */
            function (m) {
                _this.ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.naReady.emit(m); }));
                _this.logger.d(TAG, 'autocomplete is ready.');
            }));
            this.inited = true;
        }
        else {
            zip(filter.has('city'), plugin).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = tslib_1.__read(_a, 2), v = _b[0], p = _b[1];
                return p.setCity(v);
            }));
            zip(filter.has('type'), plugin).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = tslib_1.__read(_a, 2), v = _b[0], p = _b[1];
                return p.setType(v);
            }));
            zip(filter.has('citylimit'), plugin).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = tslib_1.__read(_a, 2), v = _b[0], p = _b[1];
                return p.setCityLimit(v);
            }));
        }
    };
    InputAmapAutocompleteDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[amapAutocomplete]',
                },] }
    ];
    /** @nocollapse */
    InputAmapAutocompleteDirective.ctorParameters = function () { return [
        { type: AmapAutocompleteService },
        { type: EventBinderService },
        { type: ElementRef },
        { type: LoggerService },
        { type: NgZone }
    ]; };
    InputAmapAutocompleteDirective.propDecorators = {
        type: [{ type: Input }],
        city: [{ type: Input }],
        datatype: [{ type: Input }],
        citylimit: [{ type: Input }],
        naReady: [{ type: Output }],
        naComplete: [{ type: Output }],
        naSelect: [{ type: Output }],
        naChoose: [{ type: Output }],
        naError: [{ type: Output }]
    };
    return InputAmapAutocompleteDirective;
}());
export { InputAmapAutocompleteDirective };
if (false) {
    /**
     * 输入提示时限定POI类型，多个类型用“|”分隔
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.type;
    /**
     * 输入提示时限定城市
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.city;
    /**
     * 返回的数据类型
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.datatype;
    /**
     * 是否强制限制在设置的城市内搜索
     * @type {?}
     */
    InputAmapAutocompleteDirective.prototype.citylimit;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naReady;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naComplete;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naSelect;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naChoose;
    /** @type {?} */
    InputAmapAutocompleteDirective.prototype.naError;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.inited;
    /**
     * @type {?}
     * @protected
     */
    InputAmapAutocompleteDirective.prototype.os;
    /**
     * @type {?}
     * @protected
     */
    InputAmapAutocompleteDirective.prototype.binder;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    InputAmapAutocompleteDirective.prototype.ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtYW1hcC1hdXRvY29tcGxldGUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWFtYXAvIiwic291cmNlcyI6WyJkaXJlY3RpdmVzL2lucHV0LWFtYXAtYXV0b2NvbXBsZXRlL2lucHV0LWFtYXAtYXV0b2NvbXBsZXRlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQ0wsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osU0FBUyxFQUNULFVBQVUsRUFHVixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQixPQUFPLEVBQ0wsdUJBQXVCLEdBRXhCLE1BQU0sNERBQTRELENBQUM7QUFDcEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sYUFBYSxDQUFDOztJQUVqRCxHQUFHLEdBQUcsbUJBQW1COztJQUN6QixtQkFBbUIsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFdBQVcsQ0FBQztBQUVyRTtJQThCRSx3Q0FDWSxFQUEyQixFQUMzQixNQUEwQixFQUM1QixFQUFjLEVBQ2QsTUFBcUIsRUFDckIsTUFBYztRQUpaLE9BQUUsR0FBRixFQUFFLENBQXlCO1FBQzNCLFdBQU0sR0FBTixNQUFNLENBQW9CO1FBQzVCLE9BQUUsR0FBRixFQUFFLENBQVk7UUFDZCxXQUFNLEdBQU4sTUFBTSxDQUFlO1FBQ3JCLFdBQU0sR0FBTixNQUFNLENBQVE7O1FBWmQsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFNL0IsV0FBTSxHQUFHLEtBQUssQ0FBQzs7WUFRZixNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUs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SUwsS0FBSzswQkFHTCxNQUFNOzZCQUNOLE1BQU07MkJBQ04sTUFBTTsyQkFDTixNQUFNOzBCQUNOLE1BQU07O0lBb0NULHFDQUFDO0NBQUEsQUEvREQsSUErREM7U0E1RFksOEJBQThCOzs7Ozs7SUFLekMsOENBQXNCOzs7OztJQUl0Qiw4Q0FBc0I7Ozs7O0lBSXRCLGtEQUE2Qzs7Ozs7SUFJN0MsbURBQTRCOztJQUc1QixpREFBdUM7O0lBQ3ZDLG9EQUF3Qzs7SUFDeEMsa0RBQXNDOztJQUN0QyxrREFBc0M7O0lBQ3RDLGlEQUFxQzs7Ozs7SUFFckMsZ0RBQXVCOzs7OztJQUVyQiw0Q0FBcUM7Ozs7O0lBQ3JDLGdEQUFvQzs7Ozs7SUFDcEMsNENBQXNCOzs7OztJQUN0QixnREFBNkI7Ozs7O0lBQzdCLGdEQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBPbkNoYW5nZXMsXG4gIE5nWm9uZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB6aXAgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIEFtYXBBdXRvY29tcGxldGVTZXJ2aWNlLFxuICBBTWFwQXV0b2NvbXBsZXRlLFxufSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbWFwLWF1dG9jb21wbGV0ZS9hbWFwLWF1dG9jb21wbGV0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IExvZ2dlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbG9nZ2VyL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7IEV2ZW50QmluZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9ldmVudC1iaW5kZXIuc2VydmljZSc7XG5pbXBvcnQgeyBnZXRPcHRpb25zLCBDaGFuZ2VGaWx0ZXIgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IFRBRyA9ICdhbWFwLWF1dG9jb21wbGV0ZSc7XG5jb25zdCBBdXRvY29tcGxldGVPcHRpb25zID0gWyd0eXBlJywgJ2NpdHknLCAnZGF0YXR5cGUnLCAnY2l0eWxpbWl0J107XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W2FtYXBBdXRvY29tcGxldGVdJyxcbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRBbWFwQXV0b2NvbXBsZXRlRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgLy8gLS0tLSBPcHRpb25zIC0tLS1cbiAgLyoqXG4gICAqIOi+k+WFpeaPkOekuuaXtumZkOWumlBPSeexu+Wei++8jOWkmuS4quexu+Wei+eUqOKAnHzigJ3liIbpmpRcbiAgICovXG4gIEBJbnB1dCgpIHR5cGU6IHN0cmluZztcbiAgLyoqXG4gICAqIOi+k+WFpeaPkOekuuaXtumZkOWumuWfjuW4glxuICAgKi9cbiAgQElucHV0KCkgY2l0eTogc3RyaW5nO1xuICAvKipcbiAgICog6L+U5Zue55qE5pWw5o2u57G75Z6LXG4gICAqL1xuICBASW5wdXQoKSBkYXRhdHlwZTogQU1hcEF1dG9jb21wbGV0ZS5EYXRhVHlwZTtcbiAgLyoqXG4gICAqIOaYr+WQpuW8uuWItumZkOWItuWcqOiuvue9rueahOWfjuW4guWGheaQnOe0olxuICAgKi9cbiAgQElucHV0KCkgY2l0eWxpbWl0OiBib29sZWFuO1xuXG4gIC8vIC0tLS0gRXZlbnRzIC0tLS1cbiAgQE91dHB1dCgpIG5hUmVhZHkgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBuYUNvbXBsZXRlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgQE91dHB1dCgpIG5hU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgQE91dHB1dCgpIG5hQ2hvb3NlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgQE91dHB1dCgpIG5hRXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+O1xuXG4gIHByaXZhdGUgaW5pdGVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBvczogQW1hcEF1dG9jb21wbGV0ZVNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGJpbmRlcjogRXZlbnRCaW5kZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcy5nZXQoKTtcbiAgICB0aGlzLm5hQ29tcGxldGUgPSB0aGlzLmJpbmRlci5iaW5kRXZlbnQodGFyZ2V0LCAnY29tcGxldGUnKTtcbiAgICB0aGlzLm5hU2VsZWN0ID0gdGhpcy5iaW5kZXIuYmluZEV2ZW50KHRhcmdldCwgJ3NlbGVjdCcpO1xuICAgIHRoaXMubmFDaG9vc2UgPSB0aGlzLmJpbmRlci5iaW5kRXZlbnQodGFyZ2V0LCAnY2hvb3NlJyk7XG4gICAgdGhpcy5uYUVycm9yID0gdGhpcy5iaW5kZXIuYmluZEV2ZW50KHRhcmdldCwgJ2Vycm9yJyk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgY29uc3QgZmlsdGVyID0gQ2hhbmdlRmlsdGVyLm9mKGNoYW5nZXMpO1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMub3MuZ2V0KCk7XG4gICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgdGhpcy5sb2dnZXIuZChUQUcsICdpbml0aWFsaXppbmcgLi4uJyk7XG4gICAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9uczxBTWFwQXV0b2NvbXBsZXRlLk9wdGlvbnM+KHRoaXMsIEF1dG9jb21wbGV0ZU9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5pbnB1dCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICAgIHRoaXMubG9nZ2VyLmQoVEFHLCAnb3B0aW9uczonLCBvcHRpb25zKTtcbiAgICAgIHRoaXMub3MuY3JlYXRlKG9wdGlvbnMpLnN1YnNjcmliZShtID0+IHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMubmFSZWFkeS5lbWl0KG0pKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZChUQUcsICdhdXRvY29tcGxldGUgaXMgcmVhZHkuJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgemlwKGZpbHRlci5oYXM8c3RyaW5nPignY2l0eScpLCBwbHVnaW4pLnN1YnNjcmliZSgoW3YsIHBdKSA9PiBwLnNldENpdHkodikpO1xuICAgICAgemlwKGZpbHRlci5oYXM8c3RyaW5nPigndHlwZScpLCBwbHVnaW4pLnN1YnNjcmliZSgoW3YsIHBdKSA9PiBwLnNldFR5cGUodikpO1xuICAgICAgemlwKGZpbHRlci5oYXM8Ym9vbGVhbj4oJ2NpdHlsaW1pdCcpLCBwbHVnaW4pLnN1YnNjcmliZSgoW3YsIHBdKSA9PiBwLnNldENpdHlMaW1pdCh2KSk7XG4gICAgfVxuICB9XG59XG4iXX0=